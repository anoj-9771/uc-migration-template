parameters:
- name: AzDoServiceConnection # name of the parameter; required
  type: string # data type of the parameter; required
- name: resource_group
  type: string
- name: databricks_cluster_name
  type: string
  # default: etl-cluster
- name: databricks_driver_node_type_id
  type: string
  # default: Standard_D3_v2
- name: databricks_node_type_id
  type: string
  # default: Standard_D3_v2
- name: databricks_spark_version
  type: string
  # default: 6.2.x-scala2.11
- name: databricks_workers
  type: number
  # default: 2
- name: databricks_autotermination
  type: number
  # default: 30

steps:
  - task: AzureCLI@2
    displayName: 'Create Databricks PAT'
    name: create_pat
    inputs:
      azureSubscription: ${{ parameters.AzDoServiceConnection }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        # Change these values
        RESOURCE_GROUP="${{ parameters.resource_group }}"
        DATABRICKS_WORKSPACE="$(getWorkspaceName.databricksWorkspaceName)"

        tenantId=$(az account show --query tenantId -o tsv)
        wsId=$(az resource show \
          --resource-type Microsoft.Databricks/workspaces \
          -g "$RESOURCE_GROUP" \
          -n "$DATABRICKS_WORKSPACE" \
          --query id -o tsv)

        # Get a token for the global Databricks application.
        # The resource name is fixed and never changes.
        token_response=$(az account get-access-token --resource 2ff814a6-3304-4ab8-85cb-cd0e6f879c1d)
        token=$(jq .accessToken -r <<< "$token_response")

        # Get a token for the Azure management API
        token_response=$(az account get-access-token --resource https://management.core.windows.net/)
        azToken=$(jq .accessToken -r <<< "$token_response")

        # Use both tokens in Databricks API call
        list_response=$(curl -sf https://$(LOCATION).azuredatabricks.net/api/2.0/token/list -X GET \
          -H "Authorization: Bearer $token" \
          -H "X-Databricks-Azure-SP-Management-Token:$azToken" \
          -H "X-Databricks-Azure-Workspace-Resource-Id:$wsId")
        echo "Number of PAT tokens available:"
        echo "$list_response"
        
        # Get number of tokens created for pipeline (should be 0 or 1)
        # We need to check that the token has been created by checking comment
        # and if it has been expired.
        CURRENTDATE="$(date +'%Y/%m/%d')"
        CURRENTDATEEPOCH="$(date +'%s')000"
        num_tokens=$(jq 'if (. | length) == 0 then 0 else ([.token_infos[] | .expiry_time |= (. / 1000 | strftime("%Y-%m-%d")) | select(.expiry_time > "$CURRENTDATE" and .comment == "Azure DevOps Token")] | length) end' -r --arg CURRENTDATE "$CURRENTDATE" <<< "$list_response")
        echo "Number of PAT tokens created for Azure DevOps:"
        echo "$num_tokens"

        if [ $num_tokens -gt 0 ]
        then
          echo "PAT token already created. Rolling PAT token"
          jq -r '.token_infos[] | select(.expiry_time > "$CURRENTDATEEPOCH" and .comment == "Azure DevOps Token") | .token_id' --arg CURRENTDATEEPOCH "$CURRENTDATEEPOCH"  <<< "$list_response"  | while read token_id;
          do
            echo "Deleting PAT token $id.token_id"
            api_response=$(curl -sf https://$(LOCATION).azuredatabricks.net/api/2.0/token/delete \
              -H "Authorization: Bearer $token" \
              -H "X-Databricks-Azure-SP-Management-Token:$azToken" \
              -H "X-Databricks-Azure-Workspace-Resource-Id:$wsId" \
              -d '{ "token_id": "$id" }')
            echo "$(jq -r []. | <<< $api_response)"
          done
          echo "Generating new PAT"
          api_response=$(curl -sf https://$(LOCATION).azuredatabricks.net/api/2.0/token/delete \
            -H "Authorization: Bearer $token" \
            -H "X-Databricks-Azure-SP-Management-Token:$azToken" \
            -H "X-Databricks-Azure-Workspace-Resource-Id:$wsId" \
            -d '{ "comment": "Azure DevOps Token" }')
          pat_token=$(jq .token_value -r <<< "$api_response")

          echo "##vso[task.setvariable variable=DATABRICKS_PAT_TOKEN;isOutput=true]$pat_token"
          echo "##vso[task.setvariable variable=ADD_TO_KV;isOutput=true]Yes"
        else
          # You can also generate a PAT token. Note the quota limit of 600 tokens.
          api_response=$(curl -sf https://$(LOCATION).azuredatabricks.net/api/2.0/token/create \
            -H "Authorization: Bearer $token" \
            -H "X-Databricks-Azure-SP-Management-Token:$azToken" \
            -H "X-Databricks-Azure-Workspace-Resource-Id:$wsId" \
            -d '{ "lifetime_seconds": 31557600, "comment": "Azure DevOps Token" }')
          pat_token=$(jq .token_value -r <<< "$api_response")

          echo "##vso[task.setvariable variable=DATABRICKS_PAT_TOKEN;isOutput=true]$pat_token"
          echo "##vso[task.setvariable variable=ADD_TO_KV;isOutput=true]Yes"
        fi

  - task: AzureCLI@2
    displayName: 'Add PAT to Key Vault'
    name: add_pat_to_keyvault
    condition: eq(variables['create_pat.ADD_TO_KV'], 'Yes')
    inputs:
      azureSubscription: ${{ parameters.AzDoServiceConnection }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        az keyvault set-policy --name "$(AZUREKEYVAULTNAME)" --secret-permissions set delete list get --object-id "$(SPOBJECTID)"
        az keyvault secret set --name databricks-token --vault-name "$(AZUREKEYVAULTNAME)" --value "$(create_pat.DATABRICKS_PAT_TOKEN)"

  - task: AzureKeyVault@1
    displayName: 'Get PAT from AKV'
    inputs:
      azureSubscription: ${{ parameters.AzDoServiceConnection }}
      keyVaultName: $(AZUREKEYVAULTNAME)
      secretsFilter: 'databricks-token'

  - task: AzureCLI@2
    displayName: 'Create cluster'
    name: create_cluster
    inputs:
      azureSubscription: ${{ parameters.AzDoServiceConnection }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        cluster_config='{
          "cluster_name": "${{ parameters.databricks_cluster_name }}", 
          "spark_version": "${{ parameters.databricks_spark_version }}", 
          "node_type_id": "${{ parameters.databricks_node_type_id }}",
          "driver_node_type_id": "${{ parameters.databricks_driver_node_type_id }}",
          "autotermination_minutes": ${{ parameters.databricks_autotermination }},
          "num_workers": ${{ parameters.databricks_workers }}
        }'
        echo "Generated cluster config:"
        echo "$cluster_config"

        list_response=$(curl -sf https://$(LOCATION).azuredatabricks.net/api/2.0/clusters/list -X GET \
          -H "Authorization: Bearer $(DATABRICKS-TOKEN)")
        echo "List of clusters in Databricks Workspace:"
        echo "$list_response"

        # Number of ETL clusters already created (should be 0 or 1)
        num_clusters=$(jq 'if (. | length) == 0 then 0 else ([.clusters[] | select(.cluster_name == "${{ parameters.databricks_cluster_name }}") | { cluster_id: .cluster_id }] | length) end' -r <<< "$list_response")

        if [ $num_clusters -eq 0 ]
        then
          echo "No ETL cluster found, creating..."
          api_response=$(echo $cluster_config | curl -sf https://$(LOCATION).azuredatabricks.net/api/2.0/clusters/create \
            -H "Authorization: Bearer $(DATABRICKS-TOKEN)" \
              -d @-)
          echo "$api_response"
          cluster_id=$(jq .cluster_id -r <<< "$api_response")
          echo "$cluster_id"
          echo "##vso[task.setvariable variable=cluster_id;isOutput=true]$cluster_id"
        else
          echo "Cluster already created. Nothing to do here."
        fi