/*
Deployment script for CntrlDb

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "CntrlDb"
:setvar DefaultFilePrefix "CntrlDb"
:setvar DefaultDataPath "C:\Users\ragrawal\AppData\Local\Microsoft\VisualStudio\SSDT\ADS-Database"
:setvar DefaultLogPath "C:\Users\ragrawal\AppData\Local\Microsoft\VisualStudio\SSDT\ADS-Database"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
The column [CTL].[ControlDataLoadTypes].[TruncateTarget] on table [CTL].[ControlDataLoadTypes] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.

The column [CTL].[ControlDataLoadTypes].[UpsertTarget] on table [CTL].[ControlDataLoadTypes] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [CTL].[ControlDataLoadTypes])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The type for column ProcessedToTrustedZone in table [CTL].[ControlManifest] is currently  BIGINT NULL but is being changed to  BIT NULL. Data loss could occur.
*/

IF EXISTS (select top 1 1 from [CTL].[ControlManifest])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [CTL].[ControlTasks].[DeltaLoad] is being dropped, data loss could occur.

The column [CTL].[ControlTasks].[IsCDC] is being dropped, data loss could occur.
*/

IF EXISTS (select top 1 1 from [CTL].[ControlTasks])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Rename refactoring operation with key 802caf6b-c634-4d6e-986c-037348d71db7 is skipped, element [CTL].[ControlTypes].[FileExt] (SqlSimpleColumn) will not be renamed to FileType';


GO
PRINT N'Rename refactoring operation with key 5e99db43-7b9f-45d5-8264-59a37a2a803c, 10a5fbff-cfa3-45e6-8757-66f8de20b654 is skipped, element [CTL].[fn_getWAustDateTime] (SqlScalarFunction) will not be renamed to udf_GetWAustDateTime';


GO
PRINT N'Rename refactoring operation with key fb2f0bdb-161e-464c-9b21-e0e1e295e68b is skipped, element [CTL].[getStageTableSQL] (SqlProcedure) will not be renamed to [GetStageTableSQL]';


GO
PRINT N'Rename refactoring operation with key b3b06575-75db-437b-88ee-3b7fdcb30171 is skipped, element [CTL].[getStorageFileName] (SqlProcedure) will not be renamed to GetStorageFileName';


GO
PRINT N'Rename refactoring operation with key 23fa5535-2720-4a95-996d-2de9b64146d0 is skipped, element [CTL].[updateWatermarks] (SqlProcedure) will not be renamed to [UpdateWatermarks]';


GO
PRINT N'Rename refactoring operation with key 9fa547ba-9cf3-44de-bff6-69b4db478e20 is skipped, element [CTL].[udf_getDeltaSQL] (SqlScalarFunction) will not be renamed to [udf_GetDeltaSQL]';


GO
PRINT N'Rename refactoring operation with key 15c9113f-30d3-48af-af73-6a699e91fdf0 is skipped, element [CTL].[udf_getFileDateHierarchy] (SqlScalarFunction) will not be renamed to [udf_GetFileDateHierarchy]';


GO
PRINT N'Rename refactoring operation with key ae386e6c-6867-4fdb-b146-12f67c3f6d8c is skipped, element [CTL].[udf_getLastLoadedFile] (SqlScalarFunction) will not be renamed to [udf_GetLastLoadedFile]';


GO
PRINT N'Rename refactoring operation with key b693bc61-dad7-4737-b269-ac0730eb66c3 is skipped, element [CTL].[udf_getNZDateTime] (SqlScalarFunction) will not be renamed to udf_GetNZDateTime';


GO
PRINT N'Rename refactoring operation with key 84bf20d3-232f-4b89-89bb-b57b4d976cdb is skipped, element [CTL].[getExecutionStages] (SqlProcedure) will not be renamed to [GetExecutionStages]';


GO
PRINT N'Rename refactoring operation with key 217d3362-1755-422f-af90-38548529e4d7 is skipped, element [CTL].[getProjects] (SqlProcedure) will not be renamed to [GetProjects]';


GO
PRINT N'Rename refactoring operation with key 9df84337-0070-4a60-bbe4-d36bd9b0b12b is skipped, element [CTL].[getProjectSchedule] (SqlProcedure) will not be renamed to [GetProjectSchedule]';


GO
PRINT N'Rename refactoring operation with key b0ca1000-ac6f-40bd-a8d9-c7896764dbcc is skipped, element [CTL].[getWatemarkSQL] (SqlProcedure) will not be renamed to [GetWatemarkSQL]';


GO
PRINT N'Rename refactoring operation with key 9786acad-28d8-4337-b6b5-9c6779931cb9 is skipped, element [CTL].[DataLoadType].[Id] (SqlSimpleColumn) will not be renamed to DataLoadTypeID';


GO
PRINT N'The following operation was generated from a refactoring log file e3fd0fd2-dc20-432b-b2d3-a503f45b5b0d, 5474588e-4ad7-4e97-9aa8-350a7bd63946';

PRINT N'Rename [CTL].[ControlDataLoadTypes].[IsDelta] to DeltaExtract';


GO
EXECUTE sp_rename @objname = N'[CTL].[ControlDataLoadTypes].[IsDelta]', @newname = N'DeltaExtract', @objtype = N'COLUMN';


GO
PRINT N'The following operation was generated from a refactoring log file 7adbd24a-2748-40ff-858c-7f0fb8835504, 3a43145e-b25c-463e-ae75-c9c37286eb27';

PRINT N'Rename [CTL].[ControlDataLoadTypes].[IsCDC] to CDCSource';


GO
EXECUTE sp_rename @objname = N'[CTL].[ControlDataLoadTypes].[IsCDC]', @newname = N'CDCSource', @objtype = N'COLUMN';


GO
PRINT N'Rename refactoring operation with key b45ecdfd-aba5-419e-b0cd-fa3e6a32cd7f is skipped, element [CTL].[ControlTypes].[FileExt] (SqlSimpleColumn) will not be renamed to FileType';


GO
PRINT N'The following operation was generated from a refactoring log file b725dc32-6263-46dd-be40-7e4bcca4d5cb';

PRINT N'Rename [CTL].[ControlManifest].[StageRecordProcessed] to ProcessedToTrustedZone';


GO
EXECUTE sp_rename @objname = N'[CTL].[ControlManifest].[StageRecordProcessed]', @newname = N'ProcessedToTrustedZone', @objtype = N'COLUMN';


GO
PRINT N'Rename refactoring operation with key 27afadab-1550-400e-8101-ad08c297cbfa is skipped, element [CTL].[ControlCuratedEntityDependentObjects] (SqlTable) will not be renamed to [ControlCuratedConfig]';


GO
PRINT N'Rename refactoring operation with key ce5c7c3c-aa38-43f1-958b-435bf2617c8a is skipped, element [CTL].[ControlCuratedWatermark] (SqlTable) will not be renamed to [ControlCuratedManifest]';


GO
PRINT N'Rename refactoring operation with key ce953f4d-0385-471c-a4bb-dce4bc084fd5 is skipped, element [CTL].[CuratedLogLoadPeriod] (SqlProcedure) will not be renamed to [CuratedLogLoadingPeriod]';


GO
PRINT N'Rename refactoring operation with key 1d756886-7489-4821-95f8-de06315158ed is skipped, element [CTL].[GetCuratedLoadPeriod] (SqlProcedure) will not be renamed to CuratedGetLoadingPeriod';


GO
PRINT N'Rename refactoring operation with key b61b2992-7abd-45bd-bd15-0ef6004e2448 is skipped, element [CTL].[UpdateCuratedLoadStatus] (SqlProcedure) will not be renamed to CuratedUpdateLoadStatus';


GO
PRINT N'Altering [CTL].[BatchExecutionLog]...';


GO
ALTER TABLE [CTL].[BatchExecutionLog]
    ADD [ProjectID] BIGINT NULL;


GO
PRINT N'Altering [CTL].[ControlDataLoadTypes]...';


GO
ALTER TABLE [CTL].[ControlDataLoadTypes]
    ADD [TruncateTarget] BIT NOT NULL,
        [UpsertTarget]   BIT NOT NULL;


GO
PRINT N'Starting rebuilding table [CTL].[ControlManifest]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [CTL].[tmp_ms_xx_ControlManifest] (
    [BatchExecutionLogID]    BIGINT         NOT NULL,
    [TaskExecutionLogID]     BIGINT         NOT NULL,
    [SourceObject]           VARCHAR (1000) NULL,
    [Container]              VARCHAR (1000) NULL,
    [StartCounter]           VARCHAR (500)  NULL,
    [EndCounter]             VARCHAR (500)  NULL,
    [RecordCountLoaded]      BIGINT         NULL,
    [RecordCountDeltaTable]  BIGINT         NULL,
    [FolderName]             VARCHAR (1000) NULL,
    [FileName]               VARCHAR (1000) NULL,
    [ProcessedToTrustedZone] BIT            NULL,
    [DeltaColumn]            NVARCHAR (100) NULL,
    [ProcessedToSQLEDW]      BIT            NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_CTL_ControlManifest1] PRIMARY KEY CLUSTERED ([BatchExecutionLogID] ASC, [TaskExecutionLogID] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [CTL].[ControlManifest])
    BEGIN
        INSERT INTO [CTL].[tmp_ms_xx_ControlManifest] ([BatchExecutionLogID], [TaskExecutionLogID], [SourceObject], [Container], [StartCounter], [EndCounter], [RecordCountLoaded], [FolderName], [FileName], [ProcessedToTrustedZone], [DeltaColumn])
        SELECT   [BatchExecutionLogID],
                 [TaskExecutionLogID],
                 [SourceObject],
                 [Container],
                 [StartCounter],
                 [EndCounter],
                 [RecordCountLoaded],
                 [FolderName],
                 [FileName],
                 [ProcessedToTrustedZone],
                 [DeltaColumn]
        FROM     [CTL].[ControlManifest]
        ORDER BY [BatchExecutionLogID] ASC, [TaskExecutionLogID] ASC;
    END

DROP TABLE [CTL].[ControlManifest];

EXECUTE sp_rename N'[CTL].[tmp_ms_xx_ControlManifest]', N'ControlManifest';

EXECUTE sp_rename N'[CTL].[tmp_ms_xx_constraint_PK_CTL_ControlManifest1]', N'PK_CTL_ControlManifest', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [CTL].[ControlSource]...';


GO
ALTER TABLE [CTL].[ControlSource]
    ADD [BusinessKeyColumn]  VARCHAR (100) NULL,
        [AdditionalProperty] VARCHAR (MAX) NULL;


GO
PRINT N'Altering [CTL].[ControlTasks]...';


GO
ALTER TABLE [CTL].[ControlTasks] DROP COLUMN [DeltaLoad], COLUMN [IsCDC];


GO
ALTER TABLE [CTL].[ControlTasks]
    ADD [DataLoadMode] VARCHAR (100) NULL,
        [TrackChanges] BIT           NULL,
        [LoadToSqlEDW] BIT           NULL;


GO
PRINT N'Creating [CTL].[UQ_ControlTasks_TaskName]...';


GO
ALTER TABLE [CTL].[ControlTasks]
    ADD CONSTRAINT [UQ_ControlTasks_TaskName] UNIQUE NONCLUSTERED ([TaskName] ASC, [ControlStageId] ASC, [ProjectId] ASC);


GO
PRINT N'Altering [CTL].[ControlWatermark]...';


GO
ALTER TABLE [CTL].[ControlWatermark]
    ADD [SourceName] NVARCHAR (255) NULL;


GO
PRINT N'Creating [CTL].[ControlCuratedConfig]...';


GO
CREATE TABLE [CTL].[ControlCuratedConfig] (
    [SubjectArea]        VARCHAR (255) NOT NULL,
    [Project]            VARCHAR (255) NOT NULL,
    [DependentTableName] VARCHAR (255) NOT NULL,
    [Valid]              BIT           NOT NULL,
    CONSTRAINT [PK_ControlCuratedConfig] PRIMARY KEY CLUSTERED ([SubjectArea] ASC, [Project] ASC, [DependentTableName] ASC)
);


GO
PRINT N'Creating [CTL].[ControlCuratedManifest]...';


GO
CREATE TABLE [CTL].[ControlCuratedManifest] (
    [BatchExecutionLogID] BIGINT        NOT NULL,
    [TaskExecutionLogID]  BIGINT        NOT NULL,
    [SubjectArea]         VARCHAR (255) NOT NULL,
    [Project]             VARCHAR (255) NOT NULL,
    [StartPeriod]         DATETIME      NULL,
    [EndPeriod]           DATETIME      NULL,
    [LoadStatus]          VARCHAR (100) NULL,
    [StartTimestamp]      DATETIME      NULL,
    [EndTimeStamp]        DATETIME      NULL,
    CONSTRAINT [PK_ControlCuratedManifest] PRIMARY KEY CLUSTERED ([BatchExecutionLogID] ASC, [TaskExecutionLogID] ASC)
);


GO
PRINT N'Creating [CTL].[CustomDataLoad]...';


GO
CREATE TABLE [CTL].[CustomDataLoad] (
    [TableName]          VARCHAR (255) NULL,
    [ServiceName]        VARCHAR (255) NULL,
    [StartDate]          DATETIME      NULL,
    [EndDate]            DATETIME      NULL,
    [ExtractionComplete] BIT           NULL
);


GO
PRINT N'Altering [CTL].[vw_TaskExecutionDetails]...';


GO

ALTER VIEW [CTL].[vw_TaskExecutionDetails]
AS

SELECT [ExecutionLogId]
      ,[BatchExecutionId]
      ,[ControlTaskId]
	  ,p.ProjectName
	  ,p.ProjectId
	  ,s.ControlStageId as StageId
	  ,s.StageName
	  ,t.TaskName
      ,[StartTime]
      ,[EndTime]
	  ,DATEDIFF(MINUTE,StartTime,EndTime) as Duration
      ,[ExecutionStatus]
      ,[ErrorMessage]
      ,[TaskOutput]
  FROM [CTL].[TaskExecutionLog] as l
  left join [CTL].[ControlTasks] as t 
  on l.ControlTaskId = t.TaskId
  left join [CTL].[ControlStages] as s
  on t.ControlStageId = s.ControlStageId
  left join [CTL].[ControlProjects] as p
  on t.ProjectId = p.ProjectId
  --order by BatchExecutionId desc, StartTime desc--, ExecutionStatus, duration desc
GO
PRINT N'Creating [CTL].[vw_ControlConfiguration]...';


GO





CREATE VIEW [CTL].[vw_ControlConfiguration]
AS
SELECT 
	TaskName 
	,ProjectName
	,DataLoadMode
	,BusinessKeyColumn 
	,TYPES.ControlType
	,TASKS.ControlStageId
	,TrackChanges
	,SourceLocation
	,TargetLocation
	,TaskEnabled
	,S.SourceServer
	,AdditionalProperty
	,Command
	,W.SourceColumn
	,W.Watermarks
	,S.Processor
	,TASKS.TaskId
	,S.SourceId
	,TGT.TargetId
	,P.ProjectId
FROM CTL.ControlTasks TASKS
INNER JOIN CTL.ControlSource S ON TASKS.SourceId = S.SourceId
INNER JOIN CTL.ControlTarget TGT ON TASKS.TargetId = TGT.TargetId
INNER JOIN CTL.ControlProjects P ON TASKS.ProjectId = P.ProjectId
INNER JOIN CTL.ControlTypes TYPES ON S.SourceTypeId = TYPES.TypeId
LEFT JOIN CTL.ControlTaskCommand CTC ON Tasks.TaskId = CTC.ControlTaskId
LEFT JOIN CTL.ControlWatermark W ON W.ControlSourceId = S.SourceId
GO
PRINT N'Creating [CTL].[udf_FormatFilterCol]...';


GO
CREATE FUNCTION [CTL].[udf_FormatFilterCol] (
	@Column varchar(255),
	@SourceType varchar(100)
)
Returns Varchar(MAX)
AS
BEGIN

DECLARE @COL VARCHAR(255)

IF CHARINDEX (',', @Column) > 0
BEGIN
	IF @SourceType = 'SQL Server'
		SET @COL = 'COALESCE (' + @Column + ')'
	ELSE IF @SourceType = 'Oracle'
		SET @COL = 'NVL (' + @Column + ')'
	ELSE
		SET @COL = @Column
END
ELSE
	SET @COL = @Column

RETURN @COL
END
GO
PRINT N'Creating [CTL].[udf_GetDateLocalTZ]...';


GO
CREATE FUNCTION [CTL].[udf_GetDateLocalTZ]()
returns DATETIME
as
begin
     DECLARE @DT AS datetimeoffset

     SET @DT = CONVERT(datetimeoffset, GETDATE()) AT TIME ZONE 'E. Australia Standard Time'

     RETURN CONVERT(datetime, @DT);

end
GO
PRINT N'Creating [CTL].[udf_GetDeltaSQL]...';


GO
CREATE FUNCTION [CTL].[udf_GetDeltaSQL] (@TaskId BigInt)
Returns Varchar(MAX)
AS
BEGIN
Declare @SQL Varchar(Max) = 'SELECT * ',
		@TableName Varchar(255) = ' FROM ',
		@Where Varchar(2000) = ' WHERE '

DECLARE @DataLoadMode varchar(100)
DECLARE @SourceType varchar(100)
SELECT 
	@DataLoadMode = CT.DataLoadMode 
	,@SourceType = T.ControlType
FROM CTL.ControlTasks CT 
LEFT JOIN CTL.ControlSource CS ON CT.SourceId = CS.SourceId
LEFT JOIN CTL.ControlTypes T ON CS.SourceTypeId = T.TypeId
WHERE CT.TaskId = @TaskId


--The following section checks if the source type is CDC. Use a different block altogether for CDC
IF @DataLoadMode = 'CDC'
BEGIN
	
		SELECT @TableName = @TableName + '[CDC].[' + (Select SourceName 
			FROM CTL.ControlTasks CT
			INNER JOIN CTL.ControlSource CS ON CT.SourceId = CS.SourceId
			WHERE CT.TaskId = @TaskId) + '_ct]'

		DECLARE @SQLCommand varchar(max)
		SET @SQLCommand = (SELECT Command FROM CTL.ControlTaskCommand WHERE ControlTaskId = @TaskId)
		
		
		IF UPPER(LEFT(TRIM(@SQLCommand), 8)) = 'SELECT *'
		BEGIN
			SET @SQL = @SQL + @TableName
		END
		ELSE
		BEGIN
			SET @SQL = @SQLCommand
		END

		DECLARE @WatermarkVal VARCHAR(40)
		SELECT @WatermarkVal = WM.Watermarks
		FROM CTL.ControlWatermark WM
		INNER JOIN CTL.ControlSource CS ON WM.ControlSourceId = CS.SourceId
		INNER JOIN CTL.ControlTasks CT ON CS.SourceId = CT.SourceId
		WHERE CT.TaskId = @TaskId

		SET @Where = @Where + ' UPPER([__$start_lsn]) > CONVERT(BINARY(10), ''' + @WatermarkVal + ''', 1) AND [__$operation] in (1, 2, 3, 4)'

		SET @SQL = @SQL + @Where

--End of CDC block
END
ELSE
BEGIN

	Declare @Columns Table
	(
	  ColumnName Varchar(255),
	  SourceSQL Varchar(2000)
	)

	Declare @Watermakrs Table
	(
	  Watermark Varchar(255)
	)

	--Check if there were any specific Columns in the table [ControlSourceColumns]. If not do a SELECT * from the Source
	If (Select Count(*)
		  From [CTL].[ControlSourceColumns] col
			Join [CTL].[ControlSource] cs On col.SourceTableId = cs.SourceId
			Join [CTL].[ControlTasks] ct On cs.SourceId = ct.SourceId
		 Where ct.TaskId = @TaskId) = 0
	  BEGIN
		Select @SQL = 'SELECT * '
		--If there are no specific columns configured, then use the SQL from ControlTaskCommand
		SELECT @SQL = Command FROM [CTL].ControlTaskCommand ct WHERE ControlTaskId = @TaskId
	  END
	Else
	--The following block if there were specific columns requested to be loaded from Source in ControlSourceColumns
	  BEGIN
		Select @SQL = 'SELECT '
		Select @SQL = @SQL + Case When Len(col.ColumnQuery) = 0 then col.ColumnName else col.ColumnQuery end + ', '
		  From [CTL].[ControlSourceColumns] col
			Join [CTL].[ControlSource] cs
			  On col.SourceTableId = cs.SourceId
			Join [CTL].ControlTasks ct
			  On cs.SourceId = ct.SourceId
		 Where ct.TaskId = @TaskId
		Select @SQL = Left(@SQL, Len(@SQL) - 1)

		Select @TableName = @TableName + (Select SourceLocation From CTL.ControlSource cs Join CTL.ControlTasks ct ON cs.SourceId = ct.SourceId  Where ct.TaskId = @TaskId)

		SELECT @SQL = @SQL + @TableName
	  END
	--We have our SELECT <cols> from at this stage in the variable @sql



		--Get Watermarks columns for Delta Load. There could be more than 1 columns used for Watermarks
		Insert Into @Columns
			Select m.SourceColumn, m.SourceSQL
				From [CTL].[ControlWatermark] m
					Join [CTL].[ControlSource] cs On m.ControlSourceId = cs.SourceId
				Join [CTL].[ControlTasks] ct On cs.SourceId = ct.SourceId
				Where ct.TaskId = @TaskId

		Insert Into @Watermakrs
		Select value
		  From string_split((
						Select m.Watermarks
						  From [CTL].[ControlWatermark] m
							Join [CTL].[ControlSource] cs On m.ControlSourceId = cs.SourceId
							Join [CTL].[ControlTasks] ct On cs.SourceId = ct.SourceId
						 Where ct.TaskId = @TaskId), '|')

		While (Select Count(*) From @Columns) > 0
		  BEGIN
			
			--Check if the Watermark column contains any comma, meaning there may be more than one column in it
			--If so, use the COALESCE, NVL style functions to get values
			DECLARE @COL varchar(100)
			SET @COL = (Select Top 1 SourceSQL From @Columns)
			SET @COL = [CTL].[udf_FormatFilterCol](@COL, @SourceType)

			--Updated by Rahul Agrawal on 28-Jan-2020. Updated the condition to > from >=. The >= operator loads the last watermark data over and over.
			IF @SourceType = 'Oracle'
				Select @Where = @Where  + @COL + ' > TO_DATE(''' + (Select Top 1 Watermark From @Watermakrs) + ''', ''YYYY-MM-DD HH24:MI:SS'') AND '
			ELSE
				Select @Where = @Where  + @COL + ' > ''' + (Select Top 1 Watermark From @Watermakrs) + ''' AND '

			Delete Top(1) From @Columns
			Delete Top(1) From @Watermakrs
		  END

		Select @Where = LEFT(@Where, Len(@Where) - 4)

		Select @SQL = @SQL + @Where
END

Return @SQL 
END
GO
PRINT N'Creating [CTL].[udf_GetEAustDateTime]...';


GO
CREATE FUNCTION [CTL].[udf_GetEAustDateTime](@d as datetime)
returns DATETIME
as
begin
     DECLARE @DT AS datetimeoffset

     SET @DT = CONVERT(datetimeoffset, @d) AT TIME ZONE 'E. Australia Standard Time'

     RETURN CONVERT(datetime, @DT);

end
GO
PRINT N'Creating [CTL].[udf_GetLastLoadedFile]...';


GO
CREATE Function [CTL].[udf_GetLastLoadedFile] (@SourceName Varchar(255), @SourceLocation Varchar(255))
Returns Varchar(255)
As
BEGIN
	Declare @File Varchar(255) = ''
	Select @File = (
		select a.TaskOutput from (
			Select l.TaskOutput, TargetName, TargetLocation, row_number()over(order by l.TaskOutput desc) RowNum
			  From CTL.ControlTarget targ
				Join CTL.ControlTasks t
				  On targ.TargetId = t.TargetId
				Join CTL.TaskExecutionLog l
				  On t.TaskId = l.ControlTaskId
				 And l.ExecutionStatus = 'Success'
				 And l.EndTime = (Select Max(EndTime)
									From CTL.TaskExecutionLog
								   Where ControlTaskId = t.TaskId)
				And targ.TargetName = @SourceName
	            And targ.TargetLocation = @SourceLocation
			)a where a.RowNum = 1)
	   --And a.TargetName = @SourceName
	   --And a.TargetLocation = @SourceLocation)

	Return @File
END
GO
PRINT N'Creating [CTL].[udf_GetNZDateTime]...';


GO
CREATE FUNCTION CTL.udf_GetNZDateTime(@d as datetime)
returns DATETIME
as
begin
     DECLARE @DT AS datetimeoffset

     SET @DT = CONVERT(datetimeoffset, @d) AT TIME ZONE 'New Zealand Standard Time'

     RETURN CONVERT(datetime, @DT);

end
GO
PRINT N'Creating [CTL].[udf_GetFileDateHierarchy]...';


GO




CREATE   FUNCTION [CTL].[udf_GetFileDateHierarchy] (@Grain varchar(20))
RETURNS varchar(50)
AS
BEGIN

return
(
	select Case @Grain
				WHEN 'Day' then 
					concat(
						'year=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'yyyy'), '/',
						'month=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'MM'), '/',
						'day=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'dd')
					)
				WHEN 'Month' then 
					concat(
						'year=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'yyyy'), '/',
						'month=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'MM'), '/'
					)
				WHEN 'Year' then 
					concat(
						'year=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'yyyy'), '/'
					)
				WHEN 'Hour' then 
					concat(
						'year=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'yyyy'), '/',
						'month=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'MM'), '/',
						'day=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'dd'), '/',
						'hour=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'HH')
					)
				WHEN 'Minute' then 
					concat(
						'year=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'yyyy'), '/',
						'month=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'MM'), '/',
						'day=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'dd'), '/',
						'hour=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'HH'), '/',
						'minute=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'mm')
					)
				WHEN 'Second' then 
					concat(
						'year=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'yyyy'), '/',
						'month=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'MM'), '/',
						'day=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'dd'), '/',
						'hour=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'HH'), '/',
						'minute=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'mm'), '/',
						'second=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'ss')
					)
				ELSE 
					concat(
						'year=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'yyyy'), '/',
						'month=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'MM'), '/',
						'day=',FORMAT([CTL].udf_GetNZDateTime(SYSDATETIME()),N'dd')
					)
		   End
)


END
GO
PRINT N'Creating [CTL].[udf_DelimitedSplit8K]...';


GO
CREATE FUNCTION [CTL].[udf_DelimitedSplit8K]
--===== Define I/O parameters
        (@pString VARCHAR(8000), @pDelimiter CHAR(1))
--WARNING!!! DO NOT USE MAX DATA-TYPES HERE!  IT WILL KILL PERFORMANCE!
RETURNS TABLE WITH SCHEMABINDING AS
 RETURN
--===== "Inline" CTE Driven "Tally Table" produces values from 1 up to 10,000...
     -- enough to cover VARCHAR(8000)
  WITH E1(N) AS (
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1
                ),                          --10E+1 or 10 rows
       E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows
       E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max
 cteTally(N) AS (--==== This provides the "base" CTE and limits the number of rows right up front
                     -- for both a performance gain and prevention of accidental "overruns"
                 SELECT TOP (ISNULL(DATALENGTH(@pString),0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4
                ),
cteStart(N1) AS (--==== This returns N+1 (starting position of each "element" just once for each delimiter)
                 SELECT 1 UNION ALL
                 SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@pString,t.N,1) = @pDelimiter
                ),
cteLen(N1,L1) AS(--==== Return start and length (for use in substring)
                 SELECT s.N1,
                        ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,8000)
                   FROM cteStart s
                )
--===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found.
 SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1),
        Item       = SUBSTRING(@pString, l.N1, l.L1)
   FROM cteLen l
;
GO
PRINT N'Creating [CTL].[udf_CronToDatetime]...';


GO
CREATE FUNCTION [CTL].[udf_CronToDatetime](@CRONExp varchar(50))
returns datetime2
as 
begin
	return (
		select cast(concat(Year,'/',Month,'/',DayOfMonth,' ',Hours,':',Minutes,':',Seconds) as datetime2)
		from (
			select 
				--Account for * and numeric seconds
				case when isNumeric(seconds) = 1
					then RIGHT('0'+ISNULL(Seconds,''),2)
					when isNumeric(Seconds) = 0 and Seconds = '*'
					then format([CTL].[fn_getWAustDateTime](getdate ()), 'ss')
					--Add for /
				end Seconds,
				case when isNumeric(Minutes) = 1
					then RIGHT('0'+ISNULL(Minutes,''),2)
					when isNumeric(Minutes) = 0 and Minutes = '*'
					then format([CTL].[fn_getWAustDateTime](getdate ()), 'mm')
					--Add for - /
				end Minutes,
				case when isNumeric(Hours) = 1
					then RIGHT('0'+ISNULL(Hours,''),2)
					when isNumeric(Hours) = 0 and Hours = '*'
					then format([CTL].[fn_getWAustDateTime](getdate ()), 'HH')
					--Add for - /
				end Hours,
				case when isNumeric(DayOfMonth) = 1
					then RIGHT('0'+ISNULL(DayOfMonth,''),2)
					when isNumeric(DayOfMonth) = 0 and DayOfMonth = '*'
					then datepart(dd,[CTL].[fn_getWAustDateTime](getdate ()))
					--Add for , - ? / L W
				end DayOfMonth,
				case when isNumeric(Month) = 1
					then RIGHT('0'+ISNULL(Month,''),2)
					when isNumeric(Month) = 0 and Month = '*'
					then datepart(mm,[CTL].[fn_getWAustDateTime](getdate ()))
					--Add for , - /
				end Month,
				case when isNumeric(DayOfWeek) = 1
					then RIGHT('0'+ISNULL(DayOfWeek,''),2)
					when isNumeric(DayOfWeek) = 0 and DayOfWeek = '*'
					then datepart(dw,[CTL].[fn_getWAustDateTime](getdate ()))
					--Add for , - /
				end DayOfWeek,
				case when isNumeric(Year) = 1
					then RIGHT('0'+ISNULL(Year,''),2)
					when isNumeric(Year) = 0 and (Year = '*' or Year is null) 
					then datepart(yyyy,[CTL].[fn_getWAustDateTime](getdate ()))
					--Add for , - /
				end Year
			from (
				select [1] Seconds , [2] Minutes , [3] Hours , [4] DayOfMonth, [5] Month, [6] DayOfWeek, [7] Year
				from (
						SELECT ItemNumber, Item
						FROM [CTL].[udf_DelimitedSplit8K](@CRONExp, ' ') 
					)a
					PIVOT
				(
					MAX(Item)
					FOR ItemNumber IN
						([1], [2], [3], [4], [5], [6], [7])
				) piv
			)a
		)b
	)
end
GO
PRINT N'Creating [CTL].[udf_CronToFrequency]...';


GO
CREATE FUNCTION [CTL].[udf_CronToFrequency](@CRONExp varchar(50))
returns varchar(50)
as 
begin
	return (
		select RunFrequency
		from (
			select 
				--Hierarchy for yyyy/
				case when seconds <> '*' 
					and Minutes <> '*' 
					and Hours <> '*' 
					and DayOfMonth <> '*' 
					and Month <> '*' 
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/')
				--Hierarchy for yyyy/MM/
				when seconds <> '*'
					and Minutes <> '*'
					and Hours <> '*'
					and DayOfMonth <> '*'
					and isnumeric(Month) = 1
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/')
				--Hierarchy for yyyy/MM/dd/
				when seconds <> '*'
					and Minutes <> '*'
					and Hours <> '*'
					and isnumeric(DayOfMonth) = 1
					and Month = '*'
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'dd/')
				--Hierarchy for yyyy/MM/dd/HH
				when seconds <> '*'
					and Minutes <> '*'
					and isnumeric(Hours) = 1
					and DayOfMonth = '*'
					and Month = '*'
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'dd/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'HH/')
				--Hierarchy for yyyy/MM/dd/HH/mm
				when seconds <> '*'
					and isnumeric(Minutes) = 1
					and Hours = '*'
					and DayOfMonth = '*'
					and Month = '*'
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'dd/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'HH/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'mm/') 
				--Hierarchy for yyyy/MM/dd/HH/mm/ss
				when isnumeric(seconds) = 1
					and Minutes = '*'
					and Hours = '*'
					and DayOfMonth = '*'
					and Month = '*'
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'dd/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'HH/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'mm/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'ss/') 
				end RunFrequency
			from (
				select [1] Seconds , [2] Minutes , [3] Hours , [4] DayOfMonth, [5] Month, [6] DayOfWeek, [7] Year
				from (
						SELECT ItemNumber, Item
						FROM [CTL].[udf_DelimitedSplit8K](@CRONExp, ' ') 
					)a
					PIVOT
				(
					MAX(Item)
					FOR ItemNumber IN
						([1], [2], [3], [4], [5], [6], [7])
				) piv
			)a
		)b
	)
end
GO
PRINT N'Creating [CTL].[ClearDB]...';


GO
CREATE   PROC [CTL].[ClearDB]
AS

Delete From [CTL].[ControlTaskCommand]

Delete From [CTL].[TaskExecutionLog]

Delete From [CTL].[BatchExecutionLog]

Delete From [CTL].[ControlWatermark]

Delete From [CTL].[ControlTasks]
			
Delete From [CTL].[ControlSource]
			
Delete From [CTL].[ControlTarget]

DELETE FROM CTL.ControlManifest

DBCC CHECKIDENT ('CTL.ControlTarget',Reseed,0)
DBCC CHECKIDENT ('CTL.ControlSource',Reseed,0)
DBCC CHECKIDENT ('CTL.ControlTasks',Reseed,0)
DBCC CHECKIDENT ('CTL.BatchExecutionLog',Reseed,0)
DBCC CHECKIDENT ('CTL.TaskExecutionLog',Reseed,0)
DBCC CHECKIDENT ('CTL.ControlTaskCommand',Reseed,0)
DBCC CHECKIDENT ('CTL.ControlWatermark',Reseed,0)
GO
PRINT N'Creating [CTL].[CreateBatchLog]...';


GO
CREATE Procedure [CTL].[CreateBatchLog] (@ProjectID bigint)
As
BEGIN

	If (Select Count(*) From CTL.BatchExecutionLog Where BatchExecutionStatus = 'In Progress' AND ProjectID = @ProjectID) > 0 
		BEGIN
			RAISERROR('Execution batch already in progress', 16, 1) 
		END
	Else
	  BEGIN
		Insert Into CTL.BatchExecutionLog (StartDate, BatchExecutionStatus, ProjectID) Values (getdate(), 'In Progress', @ProjectID)
		Select @@IDENTITY BatchLogId
	  END

END
GO
PRINT N'Creating [CTL].[CreateManifestRecord]...';


GO

CREATE PROCEDURE [CTL].[CreateManifestRecord] (
@BatchExecutionLogID bigint,
@TaskExecutionLogID bigint,
@SourceObject varchar(1000),
@Container varchar(1000),
@DeltaColumn varchar(100),
@StartCounter varchar(500),
@EndCounter varchar(500),
@Records bigint,
@RecordsDeltaTable bigint = 0,
@FolderName varchar(1000),
@FileName varchar(1000))
AS 

SET @DeltaColumn = ISNULL(@DeltaColumn, '')

DECLARE @Start varchar(500)
IF ISDATE(@StartCounter) = 1
	SET @Start = FORMAT(TRY_CONVERT(DATETIME, @StartCounter), 'yyyy-MM-ddTHH:mm:ss')
ELSE
	SET @Start = @StartCounter

DECLARE @End varchar(500)
IF ISDATE(@EndCounter) = 1
	SET @End = FORMAT(TRY_CONVERT(DATETIME, @EndCounter), 'yyyy-MM-ddTHH:mm:ss')
ELSE
	SET @End = @EndCounter


INSERT INTO CTL.ControlManifest(
	[BatchExecutionLogID]
	,[TaskExecutionLogID]
	,[SourceObject]
	,[Container]
	,DeltaColumn
	,StartCounter
	,EndCounter
	,RecordCountLoaded
	,RecordCountDeltaTable
	,[FolderName]
	,[FileName])
VALUES (
	@BatchExecutionLogID
	,@TaskExecutionLogID
	,@SourceObject
	,@Container
	,@DeltaColumn
	,@Start
	,@End
	,@Records
	,NULL
	,@FolderName
	,@FileName)
GO
PRINT N'Creating [CTL].[CreateTask]...';


GO




CREATE Procedure [CTL].[CreateTask] 
	@SourceName Varchar(255) = '',
    @SourceLocation Varchar(255) = '',
	@SourceTypeId BigInt = 2,  
	@SourceServer varchar(255) = '',
	@Processor varchar(255) = '',
	@TargetName Varchar(255) = '',
	@TargetLocation Varchar(255) = '',
	@TargetTypeId BigInt = 4,
	@TargetServer varchar(255)= '',
	@StageId BigInt = 2,
	@ProjectId BigInt = 1,
	@CommandType int = 1,
	@Command varchar(max)= '',
	@DataLoadMode varchar(100) = '',
	@Grain varchar(30) = '',
	@BusinessKeyColumn varchar(100) = '',
	@WatermarkColumn varchar(100) = '',
	@TrackChangeFlag bit = 0,
	@AdditionalProperty	varchar(max) = '', 
	@LoadToSqlEDW BIT = 0

As
BEGIN
	Declare	@SourceId BigInt,
	        @TargetId BigInt,
			@TaskId BigInt

	Begin Try
	Begin Transaction

		PRINT 'Adding record to ControlSource'
		Insert Into CTL.ControlSource (SourceName, SourceTypeId, SourceLocation, LoadSource, SourceServer, Processor, BusinessKeyColumn, AdditionalProperty) 
		Values(@SourceName, @SourceTypeId, @SourceLocation, 1, @SourceServer, @Processor, @BusinessKeyColumn, @AdditionalProperty)
		Select @SourceId = @@IDENTITY

		PRINT 'Adding record to ControlTarget'
		Insert Into CTL.ControlTarget (TargetName, TargetTypeId, TargetLocation, TargetEnabled, TargetServer, Compressed) 
		Values (@SourceName, @TargetTypeId, @TargetLocation, 1, @TargetServer, 1)
		Select @TargetId = @@IDENTITY

/*
		Insert Into CTL.ControlTasks (TaskName, SourceId, TargetId, DeltaLoad, TruncateTarget, TaskEnabled, LoadLatestOnly, ExecuteSourceSQLasStoredProc, ControlStageId, ProjectId, ObjectGrain, IsCDC)
		Values ('Copy ' + @SourceName, @SourceId, @TargetId, @Delta, 0, 1, 0, 1, @StageId, @ProjectId, @Grain, @IsCDC)
*/
		PRINT 'Adding record to ControlTasks'
		Insert Into CTL.ControlTasks (TaskName, SourceId, TargetId, TruncateTarget, TaskEnabled, LoadLatestOnly, 
			ExecuteSourceSQLasStoredProc, ControlStageId, ProjectId, ObjectGrain, DataLoadMode, TrackChanges, LoadToSqlEDW)
		Values (@SourceName, @SourceId, @TargetId, 0, 1, 0, 1, @StageId, @ProjectId, @Grain, @DataLoadMode, @TrackChangeFlag, @LoadToSqlEDW)
		Select @TaskId = @@IDENTITY
		
		PRINT 'Adding record to ControlTaskCommand'
		Insert Into CTL.[ControlTaskCommand] (ControlTaskId, CommandTypeId, Command)
		Values (@TaskId, @CommandType, @Command)

		--Updated by Rahul to add the default entry for Watermark for CDC Sources
		IF @DataLoadMode = 'CDC' AND @StageId = 1
		BEGIN
			PRINT 'Inserting initial watermark for CDC' 
			DECLARE @StartLSN varchar(20)
			SELECT @StartLSN = upper(sys.fn_varbintohexstr(sys.fn_cdc_map_time_to_lsn('START-LSN', '2000-01-01 12:00:00.000')))

			INSERT INTO CTL.ControlWatermark (ControlSourceId, SourceColumn, SourceSQL, Watermarks, SourceName)
			VALUES (@TaskId, '__$start_lsn', '', @StartLSN, @SourceName)
		END

		IF @DataLoadMode IN ('INCREMENTAL', 'APPEND') AND @StageId = 1
		BEGIN
			PRINT 'Inserting initial watermark column'

			INSERT INTO CTL.ControlWatermark (ControlSourceId, SourceColumn, SourceSQL, Watermarks, SourceName)
			VALUES (@SourceId, @WatermarkColumn, @WatermarkColumn, '2000-01-01 00:00:00', @SourceName)
		END


	Commit
	End Try
	Begin Catch

		Rollback
		Declare @err_num  int = @@ERROR
		Declare @err_desc varchar(500) = ERROR_MESSAGE()
		raiserror(@err_desc,@err_num,1)

	End Catch

END
GO
PRINT N'Creating [CTL].[CreateTaskLog]...';


GO
CREATE Procedure [CTL].[CreateTaskLog] (@BatchLogId BigInt, @TaskId BigInt)
As
BEGIN
	If (Select Count(*) From CTL.BatchExecutionLog Where BatchExecutionLogId = @BatchLogId And BatchExecutionStatus = 'In Progress') = 0
	  BEGIN
		RAISERROR('Batch execution log could not be located',16,1)
	  END
	Else
	  BEGIN
	    If (Select Count(*) From CTL.TaskExecutionLog Where ControlTaskId = @TaskId And ExecutionStatus = 'In Progress') > 0
		  BEGIN
			RAISERROR('Task is already in progress',16,1)
		  END
		Else
		  BEGIN
			Insert Into CTL.TaskExecutionLog (BatchExecutionId, ControlTaskId, StartTime, ExecutionStatus) 
				Values (@BatchLogId, @TaskId, [CTL].[udf_GetDateLocalTZ](), 'In Progress')
			Select @@IDENTITY TaskLogId
		  END
	  END
END
GO
PRINT N'Creating [CTL].[CuratedGetProcessingPeriod]...';


GO
CREATE PROCEDURE [CTL].[CuratedGetProcessingPeriod] (
	@SubjectArea varchar(255),
	@Project varchar(255)
	)
AS

--DECLARE @SubjectArea varchar(255) = 'NAT';
--DECLARE @Project varchar(255) = 'ComplianceCurated';

DECLARE @StartDate DATETIME;
DECLARE @EndDate DATETIME;

IF EXISTS(SELECT 1 FROM CTL.ControlCuratedConfig Config WHERE Config.SubjectArea =  @SubjectArea AND Config.Project =  @Project)
BEGIN
	--Check If there are configuration then get the dates from data load information
	WITH AllList AS (
		--Get all the data load entries from ControlManifest for the passed parameter for Curated Entity and Rank them
		SELECT  
			[SourceObject]
			,[StartCounter]
			,[EndCounter]
			,ROW_NUMBER() over (PARTITION BY SourceObject ORDER BY StartCounter desc) RowRank
		FROM [CTL].[ControlManifest]
		WHERE SourceObject in (
			--Check for matching records in the Configuration Table ControlCuratedConfig
			SELECT SourceName
			FROM CTL.ControlCuratedConfig Config
			INNER JOIN CTL.ControlSource Source ON Source.SourceLocation = Config.DependentTableName
			WHERE Config.SubjectArea =  @SubjectArea
			AND Config.Project =  @Project
			AND Config.Valid = 1
			AND ProcessedToTrustedZone = 1
		)
	), LastLoadedTime AS (
		--Take only the latest load for each table
		SELECT 
			SourceObject
			,StartCounter
			,EndCounter
		FROM AllList
		WHERE RowRank IN (1)
	)
	SELECT
		--Get the minimum of each Start Date as Processing Start Time. Default to midnight time
		@StartDate = CONVERT(DATETIME, CONVERT(DATE, (MIN(StartCounter))))
		--Get current datetime at midnight as the Processing End Time
		,@EndDate = CONVERT(DATETIME, CAST(SYSDATETIMEOFFSET() AT TIME ZONE 'AUS Eastern Standard Time' AS date))
		--*
	FROM LastLoadedTime
END
ELSE
BEGIN
	--If there are no configuration then set the default dates
	SET @StartDate = '2000-01-01 00:00:00'
	SET @EndDate = '9999-12-31 00:00:00'
END


SELECT @StartDate AS ProcessingStartDate, @EndDate AS ProcessingEndDate
GO
PRINT N'Creating [CTL].[CuratedLogComplete]...';


GO

CREATE PROCEDURE [CTL].[CuratedLogComplete] (
	@BatchExecutionLogID bigint,
	@TaskExecutionLogID bigint)
AS


UPDATE CTL.ControlCuratedManifest
SET LoadStatus = 'COMPLETE',
EndTimeStamp = [CTL].[udf_GetDateLocalTZ]()
WHERE BatchExecutionLogID = @BatchExecutionLogID
	AND TaskExecutionLogID = @TaskExecutionLogID
	AND LoadStatus = 'STARTED'
GO
PRINT N'Creating [CTL].[CuratedLogStart]...';


GO

CREATE PROCEDURE [CTL].[CuratedLogStart] (
	@BatchExecutionLogID bigint,
	@TaskExecutionLogID bigint,
	@SubjectArea varchar(255),
	@Project varchar(255),
	@StartPeriod datetime,
	@EndPeriod datetime)
AS

--Reset the previous status to Terminated if they were unfinished
UPDATE CTL.ControlCuratedManifest
SET LoadStatus = 'TERMINATED'
WHERE SubjectArea = @SubjectArea
	AND Project = @Project
	AND LoadStatus = 'STARTED'

--Create new log entry on the Manifest table
INSERT INTO CTL.ControlCuratedManifest (
	BatchExecutionLogID
	,TaskExecutionLogID
	,SubjectArea
	,Project
	,StartPeriod
	,EndPeriod
	,LoadStatus
	,StartTimestamp
	,EndTimeStamp)
VALUES (
	@BatchExecutionLogID
	,@TaskExecutionLogID
	,@SubjectArea
	,@Project
	,@StartPeriod
	,@EndPeriod
	,'STARTED'
	,[CTL].[udf_GetDateLocalTZ]()
	,NULL)
GO
PRINT N'Creating [CTL].[DeleteConfigTask]...';


GO


CREATE PROCEDURE [CTL].[DeleteConfigTask] (
	@ProjectName varchar(255),
	@TaskName varchar(255))
AS

DECLARE @StageID int = 1

DECLARE @ProjectID bigint
DECLARE @TaskID bigint, @SourceID bigint, @TargetID bigint

WHILE @StageID <= 4
BEGIN
	SELECT @ProjectID = ProjectID FROM CTL.ControlProjects WHERE ProjectName = @ProjectName

	SELECT @TaskID = TaskId, @SourceID = SourceId, @TargetID = TargetId
	FROM CTL.ControlTasks T
	WHERE T.ProjectId = @ProjectID
	AND T.TaskName = @TaskName
	AND T.ControlStageId = @StageID

	PRINT @ProjectID
	PRINT @TaskID
	PRINT @SourceID
	PRINT @TargetID


	PRINT 'Deleting from ControlWatermark'
	DELETE FROM CTL.ControlWatermark
	WHERE ControlSourceId = @SourceID

	PRINT 'Deleting from TaskExecutionLog'
	DELETE FROM CTL.TaskExecutionLog
	WHERE ControlTaskId = @TaskID

	PRINT 'Deleting from ControlTaskCommand'
	DELETE FROM CTL.ControlTaskCommand
	WHERE ControlTaskId = @TaskID

	PRINT 'Deleting from ControlWatermark'
	DELETE FROM CTL.ControlWatermark
	WHERE ControlSourceId = @TaskID

	PRINT 'Deleting from ControlTasks'
	DELETE FROM CTL.ControlTasks
	WHERE TaskId = @TaskID

	PRINT 'Deleting from ControlSource'
	DELETE FROM CTL.ControlSource
	WHERE SourceId = @SourceId

	PRINT 'Deleting from ControlTarget'
	DELETE FROM CTL.ControlTarget
	WHERE TargetId = @TargetID


	PRINT 'Deleting from ControlManifest'
	DELETE FROM CTL.ControlManifest
	WHERE SourceObject = @TaskName

	SET @StageID = @StageID + 1

END
GO
PRINT N'Creating [CTL].[DeleteProjectConfig]...';


GO
CREATE     PROC [CTL].[DeleteProjectConfig]
@projectId int
AS

Delete From [CTL].[ControlTaskCommand]
where ControlTaskId in (select TaskId from CTL.ControlTasks where ProjectId = @projectId)

DELETE FROM CTL.ControlManifest
WHERE TaskExecutionLogID IN (
	SELECT ExecutionLogID
	FROM CTL.TaskExecutionLog TEL
	LEFT JOIN CTL.ControlTasks CT ON TEL.ControlTaskId = CT.TaskId
	AND ProjectId = @projectId
)

Delete From [CTL].[TaskExecutionLog]
where ControlTaskId in (select TaskId from CTL.ControlTasks where ProjectId = @projectId)

Delete From [CTL].[BatchExecutionLog]
Where ProjectID = @projectId


Drop table if exists #tempSource
Select distinct SourceId 
Into #tempSource
From CTL.ControlSource
where SourceId in (select SourceId from CTL.ControlTasks Where ProjectId = @projectId)

Drop table if exists #tempTarget
Select distinct TargetId 
Into #tempTarget
From CTL.ControlTarget
where TargetId in (select TargetId from CTL.ControlTasks Where ProjectId = @projectId)

Delete From [CTL].[ControlWatermark]
where ControlSourceId in (select SourceId from #tempSource)

Delete From [CTL].[ControlTasks]
where SourceId in (select SourceId from #tempSource)
			
Delete From [CTL].[ControlSource]
where SourceId in (select SourceId from #tempSource)
			
Delete From [CTL].[ControlTarget]
where TargetId in (select TargetId from #tempTarget)

Drop table if exists #tempBatch
Drop table if exists #tempSource
Drop table if exists #tempTarget
GO
PRINT N'Creating [CTL].[GetAPIParams]...';


GO
CREATE PROCEDURE [CTL].[GetAPIParams] (@SourceId BigInt)
AS

BEGIN

	DECLARE @MappingInfo VARCHAR(MAX)
	IF EXISTS(SELECT 1 FROM CTL.ControlSource WHERE SourceID = @SourceId AND AdditionalProperty <> '')
	BEGIN

		DECLARE @Prop varchar(max)
		SELECT @Prop = AdditionalProperty FROM CTL.ControlSource WHERE SourceID = @SourceId

		DECLARE @CurrPos int, @NextPos int

		SET @CurrPos = 0
		SET @NextPos = CHARINDEX('|', @Prop, @CurrPos+1)
		DECLARE @Cols varchar(MAX) = SUBSTRING(@Prop, @CurrPos+1, @NextPos - @CurrPos - 1)

		SET @CurrPos = @NextPos
		SET @NextPos = CHARINDEX('|', @Prop, @CurrPos+1)
		DECLARE @CollectionFilter varchar(100) = SUBSTRING(@Prop, @CurrPos+1, @NextPos - @CurrPos - 1)

		/*********Get Mapping Information ***************/
		IF @Cols != ''
		BEGIN
			DECLARE @json_construct varchar(MAX) = '{"type": "TabularTranslator", "mappings": {X}, "collectionReference": "{CollectionFilter}"}';
			DECLARE @json VARCHAR(MAX);
    
			SET @json = (
				SELECT
					c.[value] AS 'source.path', 
					c.[value] AS 'sink.path' 
				FROM (select value from string_split(@cols, ',')) as c
			FOR JSON PATH );
 
			SET @MappingInfo = REPLACE(REPLACE(@json_construct,'{X}', @json),'{CollectionFilter}', @CollectionFilter) 
		END
	END

	SELECT @MappingInfo AS MappingInfo
END

--[CTL].[GetAPIParams] 622
GO
PRINT N'Creating [CTL].[GetExecutionStages]...';


GO


-- EXEC [CTL].[getExecutionStages] 1

Create Proc [CTL].[GetExecutionStages] (@ProjectId BigInt)
As

Select ControlStageId, StageName
From CTL.ControlStages
Where ControlStageId In (Select Distinct ControlStageId From CTL.ControlTasks Where TaskEnabled = 1 and ProjectId = @ProjectId)
Order By StageSequence
GO
PRINT N'Creating [CTL].[GetExecutionTasks]...';


GO



--[CTL].[getExecutionTasks] 1,1

CREATE Procedure [CTL].[GetExecutionTasks] (@StageId BigInt, @ProjectId BigInt)
As

With allTasks as
(
Select 
	styp.ControlType SourceType, 
	src.SourceServer, 
	src.SourceName, 
	src.SourceLocation, 
	src.AdditionalProperty,
	src.Processor, 
	p.ProjectName,
	ttyp.ControlType TargetType, 
	targ.TargetName, 
	targ.TargetLocation, 
	targ.TargetServer, 
--	targ.Compressed,
    ct.DataLoadMode, 
	DLT.DeltaExtract,
	DLT.CDCSource,
	DLT.TruncateTarget,
	DLT.UpsertTarget,
	CT.TrackChanges,
	CT.LoadToSqlEDW,
	ct.TaskName, 
	ct.ControlStageId, 
	--cps.CronExpression,  
	ct.TaskId, 
	cs.StageSequence, 
	cs.StageName, 
	src.SourceId, 
	ct.TargetId,
	ct.ObjectGrain, 
	ctc.CommandTypeId, 
	CW.Watermarks,
	FORMAT(TRY_CONVERT(DATETIME, CW.Watermarks), 'yyyy-MM-ddTHH:mm:ss') WatermarksDT,
	ISNULL(CW.SourceColumn, '') AS WatermarkColumn,
	src.BusinessKeyColumn,
	Case 
	    When (ctc.CommandTypeId = 1 OR ctc.CommandTypeId = 6) AND DLT.DeltaExtract = 1
		Then CTL.[udf_GetDeltaSQL](ct.TaskId)
		Else ctc.Command
	End Command,
	CTL.[udf_GetLastLoadedFile](src.SourceName, src.SourceLocation) LastLoadedFile

  From CTL.ControlSource src
    Join CTL.ControlTypes styp On src.SourceTypeId = styp.TypeId
    Join CTL.ControlTasks ct On src.SourceId = ct.SourceId
	Join CTL.ControlTaskCommand ctc On ct.TaskId = ctc.ControlTaskId
	Join CTL.ControlStages cs On ct.ControlStageId = cs.ControlStageId
	Join CTL.ControlTarget targ On ct.TargetId = targ.TargetId
	Join CTL.ControlTypes ttyp On targ.TargetTypeId = ttyp.TypeId
	LEFT JOIN CTL.ControlProjects P ON ct.ProjectId = p.ProjectId
	--join [CTL].[ControlProjectSchedule] cps on ct.ProjectId = cps.ControlProjectId
	LEFT JOIN CTL.ControlWatermark CW ON SRC.SourceId = CW.ControlSourceId
	LEFT JOIN CTL.ControlDataLoadTypes DLT ON CT.DataLoadMode = DLT.DataLoadType
	Left Join CTL.TaskExecutionLog tel On ct.TaskId = tel.ControlTaskId
   And tel.StartTime = (Select Max(StartTime)
                          From CTL.TaskExecutionLog
                         Where ControlTaskId = ct.TaskId)
 Where ct.TaskEnabled = 1
   And ct.ControlStageId = @StageId
   And ct.ProjectId = @ProjectId
),
lastFullExecutions As
(
Select ct.TaskId, Max(tel.EndTime) LastExecutionDate
  From CTL.ControlSource src
    Join CTL.ControlTasks ct On src.SourceId = ct.SourceId 
	Join CTL.TaskExecutionLog tel On ct.TaskId = tel.ControlTaskId
 Where ct.TaskEnabled = 1
   And ct.ControlStageId = @StageId  
   And ct.ProjectId = @ProjectId
   And tel.ExecutionStatus In ('Success', 'Failure', 'Terminated')
 Group By ct.TaskId
),
noExecutions As
(
Select ct.TaskId
  From CTL.ControlSource src
    Join CTL.ControlTasks ct On src.SourceId = ct.SourceId
	Left Join CTL.TaskExecutionLog tel On ct.TaskId = tel.ControlTaskId
 Where ct.TaskEnabled = 1
   And ct.ControlStageId = @StageId
   And ct.ProjectId = @ProjectId
   And tel.ControlTaskId Is Null
)

Select *
  From allTasks t
 Where (TaskId In (Select TaskId From noExecutions)
   Or t.TaskId In (Select ct.TaskId 
                   From CTL.ControlTasks ct
				     Join lastFullExecutions ex
					   On ct.TaskId = ex.TaskId))
				  --Where (Case 
				  --        When ct.RunFrequencyTypeId = 1 and DATEDIFF(Hour,ex.lastExecutionDate, getdate()) > 24 --Daily
						--    then 1
						--  When ct.RunFrequencyTypeId = 2 and DATEDIFF(Hour, ex.lastExecutionDate, getdate()) > 1 --Hourly
						--    then 1
						--  When ct.RunFrequencyTypeId = 3 and DATEDIFF(day, ex.lastExecutionDate, getdate()) > 7 --Annualy
						--    then 1
						--  Else 0
						--End) = 1))
 Order BY t.StageSequence, t.TaskId
GO
PRINT N'Creating [CTL].[GetManifestRecords]...';


GO
CREATE PROCEDURE [CTL].[GetManifestRecords] (
@BatchID bigint)
AS
SELECT [BatchExecutionLogID]
      ,TaskExecutionLogID
      ,[SourceObject]
      ,[Container]
      ,[StartCounter]
      ,[EndCounter]
      ,RecordCountLoaded
      ,[FolderName]
      ,[FileName]
  FROM [CTL].[ControlManifest]
  WHERE BatchExecutionLogID = @BatchID
GO
PRINT N'Creating [CTL].[GetProjects]...';


GO
CREATE PROCEDURE [CTL].[GetProjects] (
	@ProjectName varchar(100)
)
As

SELECT ProjectId as ControlProjectID, ProjectName 
FROM CTL.ControlProjects
WHERE Enabled = 1
AND ProjectName = @ProjectName
GO
PRINT N'Creating [CTL].[GetProjectSchedule]...';


GO
CREATE PROCEDURE [CTL].[GetProjectSchedule]
As

With times as
(
Select p.ProjectName, ps.*, 
	   [CTL].[fn_getWAustDateTime](getdate()) CurrentTime,
       [CTL].[udf_CronToDatetime](ps.CronExpression) ExecutionTime
  From [CTL].[ControlProjects] p
    Join [CTL].[ControlProjectSchedule] ps
      On p.ProjectId = ps.ControlProjectId
 Where p.Enabled = 1
)

Select t.ControlProjectId, t.ProjectName, format(t.ExecutionTime, 'HH:mm:ss')
  From times t
 Where Case When CurrentTime >= ExecutionTime And CurrentTime <= DATEADD(MI, 10, ExecutionTime)
         Then 1
         Else 0
       End = 1
GO
PRINT N'Creating [CTL].[GetStageTableSQL]...';


GO
CREATE Procedure [CTL].[GetStageTableSQL] (@TargetId BigInt)
As
  Declare @Output table (command varchar(max))
  Declare @SQL varchar(max) = ''


  BEGIN
    If (Select Count(*)
          From CTL.ControlTarget ct
            Join CTL.ControlTargetColumns ctc
              On ct.TargetId = ctc.TargetId
         Where ct.TargetId = @TargetId) = 0
      BEGIN
        RAISERROR('Target table definition is not available.',16,1)
      END
    Else
      BEGIN
        Insert into @Output
        Select 'Exec (''DROP TABLE IF EXISTS ' + ct.TargetLocation + '.' + ct.TargetName + char(10) + char(13) + char(10) + char(13) + ''') Select 1'
          From CTL.ControlTarget ct
         Where ct.TargetId = @TargetId

        Select @SQL = 'Exec(''CREATE TABLE ' + ct.TargetLocation + '.' + ct.TargetName + ' ( '
          From CTL.ControlTarget ct
         Where ct.TargetId = @TargetId

        Select @SQL = @SQL + ColumnName + '  ' + DataType + Case When ctc.MaxLength = -1 then '(MAX)' 
                  When ctc.MaxLength = 0 then '' else '(' + Convert(varchar, ctc.MaxLength) + case when ctc.Precision = 0 then ')' else ', ' + convert(varchar, ctc.Precision) + ')' end end + ', '
          From CTL.ControlTargetColumns ctc
         Where ctc.TargetId = @TargetId
         
        Select @SQL = LEFT(@SQL, LEN(@SQL) - 1) + ' )'')' + char(10) + char(13) + char(10) + char(13) + ' Select 1'

        Insert into @Output Values (@SQL)

        Select * From @Output

      END

  END
GO
PRINT N'Creating [CTL].[GetStorageFileName]...';


GO
CREATE proc [CTL].[GetStorageFileName] (
	@FolderName varchar(255)
	,@FileName varchar(255)
	,@Grain varchar(30)
	,@DeltaExtract bit
	,@TargetType varchar(255)
	,@Compressed bit = 1)
as
begin
	
	set @FolderName = LOWER(@FolderName)
	declare @DataType varchar(10)

	IF @TargetType = 'BLOB Storage (csv)' SET @DataType = 'csv'
	ELSE IF @TargetType = 'BLOB Storage (json)' SET @DataType = 'json'
	ELSE IF @TargetType = 'BLOB Storage (parquet)' SET @DataType = 'parquet'
	ELSE SET @DataType = 'csv'

	declare @blobfoldername varchar(1000)
	set @blobfoldername = @FolderName + '/' + @DataType + '/' + [CTL].[udf_GetFileDateHierarchy](@Grain) + '/'

	declare @blobfilename varchar(1000)
	IF @DeltaExtract = 1
	BEGIN
		set @blobfilename = @FileName + '_' + format([CTL].[udf_GetDateLocalTZ](),N'yyyy-MM-dd_HHmmss_fff') + '.' + @DataType
	END
	ELSE
	BEGIN
		set @blobfilename = @FileName + '_' + format([CTL].[udf_GetDateLocalTZ](),N'yyyy-MM-dd') + '.' + @DataType
		--Sometimes when the file with the same name is overwritten, Databricks does not read any record
		--Trying to check if having a unique name helps
		set @blobfilename = @FileName + '_' + format([CTL].[udf_GetDateLocalTZ](),N'yyyy-MM-dd_HHmmss_fff') + '.' + @DataType
	END

	IF @Compressed = 1 SET @blobfilename = @blobfilename + '.gz'


	SELECT @blobfoldername AS StorageFolder, @blobfilename AS StorageFile

end
GO
PRINT N'Creating [CTL].[GetWatemarkSQL]...';


GO
CREATE Procedure [CTL].[GetWatemarkSQL] @SourceId BigInt
As

BEGIN
Declare @SQL Varchar(2000) = 'SELECT ',
		@TableName Varchar(255) = ' FROM '


DECLARE @DataLoadMode varchar(100)
DECLARE @SourceType varchar(100)
SELECT 
	@DataLoadMode = CT.DataLoadMode 
	,@SourceType = T.ControlType
FROM CTL.ControlTasks CT 
LEFT JOIN CTL.ControlSource CS ON CT.SourceId = CS.SourceId
LEFT JOIN CTL.ControlTypes T ON CS.SourceTypeId = T.TypeId
WHERE CS.SourceId = @SourceId

IF @DataLoadMode = 'CDC'
	BEGIN
		SELECT @SQL = 'SELECT ''UPPER([__$start_lsn])'' AS SourceColumn, upper(sys.fn_varbintohexstr(sys.fn_cdc_get_max_lsn())) AS ReturnValue, sys.fn_cdc_map_lsn_to_time(sys.fn_cdc_get_max_lsn()) AS ReturnTime'
	END
ELSE
	BEGIN
		Select @TableName = @TableName + (Select SourceLocation From CTL.ControlSource Where SourceId = @SourceId)
	
		Declare @Columns Table
		(
		  ColumnName Varchar(255),
		  SourceSQL Varchar(2000)
		)

		Insert Into @Columns
			Select m.SourceColumn, m.SourceSQL
				From CTL.ControlWatermark m
				Where ControlSourceId = @SourceId

		While (Select Count(*) From @Columns) > 0
		  BEGIN

			--Check if the Watermark column contains any comma, meaning there may be more than one column in it
			--If so, use the COALESCE, NVL style functions to get values
			DECLARE @COL varchar(100)
			SET @COL = (Select Top 1 ColumnName From @Columns)
			SET @COL = [CTL].[udf_FormatFilterCol](@COL, @SourceType)

			--Updated by Rahul Agrawal on 28-Jan-2020. Updated the condition to > from >=. The >= operator loads the last watermark data over and over.
			IF @SourceType = 'Oracle'
				Select @SQL = @SQL + ' ''' + @COL + ''' As SourceColumn,  TO_CHAR(MAX(' + @COL + '), ''YYYY-MM-DD HH24:MI:SS'') As ReturnValue, '
			ELSE
				--Select @SQL = @SQL + ' ''' + @COL + ''' As SourceColumn,  FORMAT(MAX(' + @COL + '), ''yyyy-MM-dd hh:mm:ss'') As ReturnValue, '
				Select @SQL = @SQL + ' ''' + @COL + ''' As SourceColumn,  FORMAT(MAX(' + @COL + '), ''yyyy-MM-dd HH:mm:ss'') As ReturnValue, '

--			Select @SQL = @SQL + ' ''' + (Select Top 1 ColumnName From @Columns) + ''' As SourceColumn,  MAX(' + @UpdateCol + ') As ReturnValue, '
--			Delete Top(1) From @Columns

			Delete Top(1) From @Columns
		  END

		Select @SQL = LEFT(@SQL, Len(@SQL) - 1)

		Select @SQL = @SQL + @TableName

	END


Select @SQL SQLStatement

END
GO
PRINT N'Creating [CTL].[ResetLogs]...';


GO

CREATE PROCEDURE [CTL].[ResetLogs] (@ProjectID INT)
AS

UPDATE ctl.TaskExecutionLog 
SET ExecutionStatus = 'Terminated'
WHERE ExecutionStatus = 'In Progress' AND BatchExecutionId IN 
	(select BatchExecutionLogID from ctl.BatchExecutionLog where ProjectID = @ProjectID)

UPDATE CTL.BatchExecutionLog 
SET BatchExecutionStatus = 'Terminated'
WHERE BatchExecutionStatus = 'In Progress' AND ProjectID = @ProjectID

/*
delete from ctl.TaskExecutionLog where BatchExecutionId IN (select BatchExecutionLogID from ctl.BatchExecutionLog where BatchExecutionStatus = 'In Progress')
delete from ctl.BatchExecutionLog where BatchExecutionStatus = 'In Progress'
delete from ctl.TaskExecutionLog where ExecutionStatus = 'In Progress'

*/
GO
PRINT N'Creating [CTL].[UpdateBatchLog]...';


GO
CREATE Procedure [CTL].[UpdateBatchLog] (@BatchLogId BigInt, @Status Varchar(50), @ErrorMessage Varchar(2000))
As
BEGIN

	If (Select Count(*) From CTL.BatchExecutionLog Where BatchExecutionLogId = @BatchLogId) = 0 
		BEGIN
			RAISERROR('Execution batch could not be located', 16, 1) 
		END
	Else
	  BEGIN
		Update CTL.BatchExecutionLog
		   Set EndDate = [CTL].[udf_GetDateLocalTZ](),
		       BatchExecutionStatus = @Status,
			   ErrorMessage = @ErrorMessage
		 Where BatchExecutionLogId = @BatchLogId
	  END

END
GO
PRINT N'Creating [CTL].[UpdateCustomDataLoad]...';


GO
create procedure CTL.UpdateCustomDataLoad (
@TableName varchar(255),
@StartDate date)
AS

UPDATE CTL.CustomDataLoad SET ExtractionComplete = 1
WHERE TableName = @TableName
AND StartDate = @StartDate
GO
PRINT N'Creating [CTL].[UpdateManifestDeltaRecords]...';


GO
CREATE PROCEDURE [CTL].[UpdateManifestDeltaRecords] (
	@BatchExecutionLogID bigint,
	@TaskExecutionLogID bigint,
	@RecordsDeltaTable bigint)
AS

BEGIN
	UPDATE CTL.ControlManifest
	SET RecordCountDeltaTable = @RecordsDeltaTable
	WHERE BatchExecutionLogID = @BatchExecutionLogID
	AND TaskExecutionLogID = @TaskExecutionLogID
END
GO
PRINT N'Creating [CTL].[UpdateManifestDLTrusted]...';


GO
CREATE PROCEDURE [CTL].[UpdateManifestDLTrusted] (
	@SourceObject varchar(255),
	@BatchExecutionLogID bigint,
	@StartCounter varchar(255))
AS

BEGIN
	UPDATE CTL.ControlManifest
	SET [ProcessedToTrustedZone] = 1
	WHERE [ProcessedToTrustedZone] IS NULL
	AND BatchExecutionLogID = @BatchExecutionLogID
	AND SourceObject = @SourceObject
	AND StartCounter = @StartCounter
END
GO
PRINT N'Creating [CTL].[UpdateManifestSQLEDW]...';


GO
CREATE PROCEDURE [CTL].[UpdateManifestSQLEDW] (
	@BatchExecutionLogID bigint,
	@SourceObject varchar(255),
	@ProcessedToSQLEDW char(1))
AS

BEGIN
	IF @ProcessedToSQLEDW = '1'
		UPDATE CTL.ControlManifest
		SET [ProcessedToSQLEDW] = 1
		WHERE [ProcessedToSQLEDW] IS NULL
		AND BatchExecutionLogID <= @BatchExecutionLogID
		AND SourceObject = @SourceObject
END
GO
PRINT N'Creating [CTL].[UpdateTaskLog]...';


GO
CREATE Procedure [CTL].[UpdateTaskLog] (@BatchLogId BigInt, @TaskId BigInt, @ExecutionLogId BigInt, @Status Varchar(50), @ErrorMessage varchar(2000), @Output Varchar(2000))
As
BEGIN
	If (Select Count(*) From CTL.BatchExecutionLog Where BatchExecutionLogId = @BatchLogId And BatchExecutionStatus = 'In Progress') = 0
	  BEGIN
		RAISERROR('Batch execution log could not be located',16,1)
	  END
	Else
	  BEGIN
	    If (Select Count(*) From CTL.TaskExecutionLog Where ControlTaskId = @TaskId And ExecutionStatus = 'In Progress') = 0
		  BEGIN
			RAISERROR('Task execution log could not be located',16,1)
		  END
		Else
		  BEGIN
			Update CTL.TaskExecutionLog
			   Set EndTime = [CTL].[udf_GetDateLocalTZ](),
			       ExecutionStatus = @Status,
				   ErrorMessage = @ErrorMessage,
				   TaskOutput = @Output
			 Where ExecutionLogId = @ExecutionLogId
		  END
	  END
END
GO
PRINT N'Creating [CTL].[UpdateWatermarks]...';


GO
CREATE Procedure [CTL].[UpdateWatermarks] @SourceId BigInt, @Watermark Varchar(1000)
As

BEGIN


	DECLARE @WatermarkUpdated varchar(500)
	IF ISDATE(@WatermarkUpdated) = 1
		SET @WatermarkUpdated = FORMAT(TRY_CONVERT(DATETIME, @Watermark), 'yyyy-MM-ddTHH:mm:ss')
	ELSE
		SET @WatermarkUpdated = @Watermark

	Update CTL.ControlWatermark
	   Set Watermarks = @WatermarkUpdated
	 Where ControlSourceId = @SourceId
END
GO
PRINT N'Creating [CTL].[CreateSource]...';


GO


CREATE PROC [CTL].[CreateSource] 
        @ProjectName		 varchar(100),
		@StartStageName		 varchar(100),
		@EndStageName		 varchar(100),
		@SourceName			 varchar(100),
		@SourceObjectName	 varchar(500),
		@SourceType			 varchar(100),
		@DataLoadMode		 varchar(100),
		@SourceSecretName	 varchar(100),
		@DLRawSecret		 varchar(100),
		@DLStagedSecret		 varchar(100),
		@DBProcessor		 varchar(100),
		@StageDBSecret		 varchar(100),
		@DLRawSubFolder		 varchar(100),
		@DLRawType			 varchar(100),
		@DLStagedMainFolder	 varchar(100),
		@DLStagedSubFolder	 varchar(100),
		@DLStagedType		 varchar(100),
		@DLObjectGrain		 varchar(100),
		@SourceCommand		 varchar(5000),
		@DLRawtoStageCommand varchar(5000),
		@DLStagetoDBCommand  varchar(5000),
		@TargetObjectType	 varchar(100),
		@TargetOverride		 varchar(150),
		@BusinessKeyColumn	 varchar(150),
		@WatermarkColumn	 varchar(150),
		@TrackChanges		 varchar(100),
		@AdditionalProperty	 varchar(max),
		@LoadToSqlEDW		 bit = 1

as 

declare @TargetName varchar(1000), @TargetLocation varchar(1000)
SET @TargetName = @SourceObjectName
SET @TargetLocation = @DLRawSubFolder

declare @project int
declare @startStage int
declare @endStage int
declare @sourceTypeId int, @rawTypeId int, @stageTypeId int, @databricksTypeId int
--declare @deltaFlag int
declare @taskName varchar(650)
declare @stagingTable varchar(650)
declare @EDWTable varchar(650)

declare @error varchar(1000)
declare @counter int
declare @currentStage varchar(50)

declare @cdcflag int
declare @TrackChangeFlag bit
IF UPPER(@TrackChanges) = 'YES' 
	SET @TrackChangeFlag = 1
ELSE
	SET @TrackChangeFlag = 0

--If Data Load Mode is TRUNCATE-LOAD then TrackChange is false
IF @DataLoadMode = 'TRUNCATE-LOAD'
	SET @TrackChangeFlag = 0

IF @DataLoadMode = 'INCREMENTAL' AND @WatermarkColumn = ''
BEGIN
	RAISERROR('Please specify a WatermarkColumn when the data load mode is INCREMENTAL', 16, 1)
	RETURN
END

IF @DataLoadMode != 'TRUNCATE-LOAD' AND @BusinessKeyColumn = ''
BEGIN
	RAISERROR('Please specify a BusinessKeyColumn column when the data load mode is not TRUNCATE-LOAD', 16, 1) 
	RETURN
END

IF @TrackChangeFlag = 1 AND @BusinessKeyColumn = ''
BEGIN
	RAISERROR('Please specify a BusinessKeyColumn column when TrackChanges is Yes', 16, 1) 
	RETURN
END

--Get project id
set @project = (select ProjectId from [CTL].[ControlProjects] where ProjectName = @ProjectName)

set @error = 'Invalid project name: ' + @ProjectName
if @project is null raiserror(@error,16,1)

--Get start stage id
set @startStage = (select ControlStageId from [CTL].[ControlStages] where StageName = @StartStageName)

set @error = 'Invalid starting stage: ' + @StartStageName
if @startStage is null raiserror(@error,16,1)

--Get end stage id
set @endStage = (select ControlStageId from [CTL].[ControlStages] where StageName = @EndStageName)

set @error = 'Invalid starting stage: ' + @EndStageName
if @endStage is null raiserror(@error,16,1)

--Get source type id
set @sourceTypeId = (select TypeId from [CTL].[ControlTypes] where ControlType = @SourceType)

set @error = 'Invalid source type: ' + @SourceType
if @sourceTypeId is null raiserror(@error,16,1)

--Get raw type id
set @rawTypeId = (select TypeId from [CTL].[ControlTypes] where ControlType = @DLRawType)

set @error = 'Invalid raw zone type: ' + @DLRawType
if @rawTypeId is null raiserror(@error,16,1)

--Get stage type id
set @stageTypeId = (select TypeId from [CTL].[ControlTypes] where ControlType = @DLStagedType)

set @error = 'Invalid stage zone type: ' + @DLStagedType
if @stageTypeId is null raiserror(@error,16,1)


DECLARE @StageFolder varchar(100)
SET @StageFolder =  @DLStagedMainFolder + '/' + @DLStagedSubFolder

--set @deltaFlag = case when @Delta = 'Yes' then 1 else 0 end
set @databricksTypeId = (select typeid from [CTL].[ControlTypes] where ControlType = 'Databricks')
set @stagingTable = @SourceName + '.' + @DLStagedSubFolder
set @stagingTable = 'STG' + '.' + @DLStagedSubFolder

if @TargetOverride = ''
set @EDWTable = @SourceName + '.' + replace(@SourceObjectName,'vw_','')
else
set @EDWTable = @TargetOverride

set @counter = @startStage
While @counter <= @endStage
begin
	
	PRINT 'Starting ' + CONVERT(VARCHAR, @counter)

	set @currentStage = (select StageName from [CTL].[ControlStages] where ControlStageId = @counter)
	set @taskName = replace(replace(trim(@SourceName + '_' + @SourceObjectName),'[',''),']','')
	set @targetName = replace(replace(trim(@SourceObjectName),'[',''),']','')

	PRINT @currentStage + ' - ' + @taskName + ' - ' + @targetName

	if @currentStage = 'Source to Raw'
		EXEC [CTL].[CreateTask] 
		@SourceName
		,@SourceObjectName
		,@sourceTypeId
		,@SourceSecretName
		,@DBProcessor
		,@TargetName
		,@TargetLocation
		,@rawTypeId
		,@DLRawSecret
		,@counter
		,@project
		,@sourceTypeId
		,@SourceCommand
		,@DataLoadMode
		,@DLObjectGrain
		,@BusinessKeyColumn
		,@WatermarkColumn
		,@TrackChangeFlag
		,@AdditionalProperty
		,@LoadToSqlEDW

/*	
		EXEC [CTL].[CreateTask] @taskName
		,@SourceObjectName
		,@sourceTypeId
		,@SourceSecretName
		,''
		,@DLRawSubFolder
		,@SourceName
		,@rawTypeId
		,@DLRawSecret
		,@counter
		,@project
		,@sourceTypeId
		,@SourceCommand
		,@deltaFlag
		,@DLObjectGrain
		,@cdcflag
*/

    if @currentStage = 'Raw to Trusted'
		EXEC [CTL].[CreateTask] 
		@SourceName
		,@TargetLocation
		,@rawTypeId
		,@DLRawSecret
		,@DBProcessor
		,@DLRawSubFolder
		,@StageFolder
		,@stageTypeId
		,@DLStagedSecret
		,@counter
		,@project
		,@databricksTypeId
		,@DLRawtoStageCommand
		,@DataLoadMode
		,@DLObjectGrain
		,@BusinessKeyColumn
		,@WatermarkColumn
		,@TrackChangeFlag
		,@AdditionalProperty
		,@LoadToSqlEDW
	

	if @currentStage = 'Trusted to Curated'
	BEGIN

		PRINT @targetName

		EXEC [CTL].[CreateTask] 
		@SourceName
		,@DLStagedMainFolder
		,@stageTypeId
		,@DLStagedSecret
		,@DBProcessor
		,@DLRawSubFolder 
		,@targetName
		,1
		,@StageDBSecret
		,@counter
		,@project
		,@databricksTypeId
		,@DLStagetoDBCommand
		,0
		,@DLObjectGrain
		,@BusinessKeyColumn
		,@WatermarkColumn
		,@TrackChangeFlag
		,@AdditionalProperty
		,@LoadToSqlEDW
	END	






	set @counter += 1
end
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '5e99db43-7b9f-45d5-8264-59a37a2a803c')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('5e99db43-7b9f-45d5-8264-59a37a2a803c')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'fb2f0bdb-161e-464c-9b21-e0e1e295e68b')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('fb2f0bdb-161e-464c-9b21-e0e1e295e68b')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b3b06575-75db-437b-88ee-3b7fdcb30171')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b3b06575-75db-437b-88ee-3b7fdcb30171')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '23fa5535-2720-4a95-996d-2de9b64146d0')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('23fa5535-2720-4a95-996d-2de9b64146d0')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '9fa547ba-9cf3-44de-bff6-69b4db478e20')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('9fa547ba-9cf3-44de-bff6-69b4db478e20')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '15c9113f-30d3-48af-af73-6a699e91fdf0')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('15c9113f-30d3-48af-af73-6a699e91fdf0')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'ae386e6c-6867-4fdb-b146-12f67c3f6d8c')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('ae386e6c-6867-4fdb-b146-12f67c3f6d8c')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b693bc61-dad7-4737-b269-ac0730eb66c3')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b693bc61-dad7-4737-b269-ac0730eb66c3')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '10a5fbff-cfa3-45e6-8757-66f8de20b654')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('10a5fbff-cfa3-45e6-8757-66f8de20b654')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '84bf20d3-232f-4b89-89bb-b57b4d976cdb')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('84bf20d3-232f-4b89-89bb-b57b4d976cdb')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '217d3362-1755-422f-af90-38548529e4d7')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('217d3362-1755-422f-af90-38548529e4d7')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '9df84337-0070-4a60-bbe4-d36bd9b0b12b')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('9df84337-0070-4a60-bbe4-d36bd9b0b12b')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b0ca1000-ac6f-40bd-a8d9-c7896764dbcc')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b0ca1000-ac6f-40bd-a8d9-c7896764dbcc')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '9786acad-28d8-4337-b6b5-9c6779931cb9')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('9786acad-28d8-4337-b6b5-9c6779931cb9')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'e3fd0fd2-dc20-432b-b2d3-a503f45b5b0d')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('e3fd0fd2-dc20-432b-b2d3-a503f45b5b0d')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '7adbd24a-2748-40ff-858c-7f0fb8835504')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('7adbd24a-2748-40ff-858c-7f0fb8835504')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '5474588e-4ad7-4e97-9aa8-350a7bd63946')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('5474588e-4ad7-4e97-9aa8-350a7bd63946')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '3a43145e-b25c-463e-ae75-c9c37286eb27')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('3a43145e-b25c-463e-ae75-c9c37286eb27')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '802caf6b-c634-4d6e-986c-037348d71db7')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('802caf6b-c634-4d6e-986c-037348d71db7')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b45ecdfd-aba5-419e-b0cd-fa3e6a32cd7f')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b45ecdfd-aba5-419e-b0cd-fa3e6a32cd7f')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b725dc32-6263-46dd-be40-7e4bcca4d5cb')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b725dc32-6263-46dd-be40-7e4bcca4d5cb')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '27afadab-1550-400e-8101-ad08c297cbfa')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('27afadab-1550-400e-8101-ad08c297cbfa')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'ce5c7c3c-aa38-43f1-958b-435bf2617c8a')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('ce5c7c3c-aa38-43f1-958b-435bf2617c8a')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'ce953f4d-0385-471c-a4bb-dce4bc084fd5')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('ce953f4d-0385-471c-a4bb-dce4bc084fd5')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '1d756886-7489-4821-95f8-de06315158ed')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('1d756886-7489-4821-95f8-de06315158ed')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b61b2992-7abd-45bd-bd15-0ef6004e2448')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b61b2992-7abd-45bd-bd15-0ef6004e2448')

GO

GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
IF (
	SELECT p.rows 
	FROM sys.tables t 
	JOIN sys.schemas s ON t.schema_id = s.schema_id
	JOIN sys.partitions p ON t.object_id = p.object_id 
	WHERE s.name = 'CTL' 
	AND t.name = 'ControlStages'
) = 0
	BEGIN
		SET IDENTITY_INSERT [CTL].[ControlStages] ON 
		INSERT [CTL].[ControlStages] ([ControlStageId], [StageSequence], [StageName]) VALUES (1, 100, N'Source to Raw')
		INSERT [CTL].[ControlStages] ([ControlStageId], [StageSequence], [StageName]) VALUES (2, 200, N'Raw to Trusted')
		INSERT [CTL].[ControlStages] ([ControlStageId], [StageSequence], [StageName]) VALUES (3, 300, N'Trusted to Curated')
		INSERT [CTL].[ControlStages] ([ControlStageId], [StageSequence], [StageName]) VALUES (4, 400, N'Staging to DW')
		SET IDENTITY_INSERT [CTL].[ControlStages] OFF
	END

IF (
	SELECT p.rows 
	FROM sys.tables t 
	JOIN sys.schemas s ON t.schema_id = s.schema_id
	JOIN sys.partitions p ON t.object_id = p.object_id 
	WHERE s.name = 'CTL' 
	AND t.name = 'ControlTypes'
) = 0
	BEGIN
		SET IDENTITY_INSERT [CTL].[ControlTypes] ON
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (1, N'SQL Server')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (2, N'BLOB Storage (csv)')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (3, N'BLOB Storage (json)')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (4, N'BLOB Storage (parquet)')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (5, N'Flat File')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (6, N'Oracle')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (7, N'XML')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (8, N'Databricks')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (9, N'ODBC')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (10, N'Excel')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (11, N'OData-Basic')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (12, N'OData-AADServicePrincipal')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (13, N'SharePoint')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (14, N'API-TAFE')
		INSERT [CTL].[ControlTypes] ([TypeId], [ControlType]) VALUES (15, N'API-General')
		SET IDENTITY_INSERT [CTL].[ControlTypes] OFF
	END

IF (
	SELECT p.rows 
	FROM sys.tables t 
	JOIN sys.schemas s ON t.schema_id = s.schema_id
	JOIN sys.partitions p ON t.object_id = p.object_id 
	WHERE s.name = 'CTL' 
	AND t.name = 'ControlDataLoadTypes'
) = 0
	BEGIN
		SET IDENTITY_INSERT [CTL].[ControlDataLoadTypes] ON
		INSERT [CTL].[ControlDataLoadTypes] (DataLoadTypeID, [DataLoadType], [DeltaExtract], [CDCSource], TruncateTarget, UpsertTarget) VALUES (1, N'TRUNCATE-LOAD', 0, 0, 1, 0)
		INSERT [CTL].[ControlDataLoadTypes] (DataLoadTypeID, [DataLoadType], [DeltaExtract], [CDCSource], TruncateTarget, UpsertTarget) VALUES (2, N'FULL-EXTRACT', 0, 0, 0, 1)
		INSERT [CTL].[ControlDataLoadTypes] (DataLoadTypeID, [DataLoadType], [DeltaExtract], [CDCSource], TruncateTarget, UpsertTarget) VALUES (3, N'INCREMENTAL', 1, 0, 0, 1)
		INSERT [CTL].[ControlDataLoadTypes] (DataLoadTypeID, [DataLoadType], [DeltaExtract], [CDCSource], TruncateTarget, UpsertTarget) VALUES (4, N'APPEND', 1, 0, 0, 0)
		INSERT [CTL].[ControlDataLoadTypes] (DataLoadTypeID, [DataLoadType], [DeltaExtract], [CDCSource], TruncateTarget, UpsertTarget) VALUES (5, N'CDC', 1, 1, 0, 0)
		SET IDENTITY_INSERT [CTL].[ControlDataLoadTypes] OFF
	END


	
  UPDATE CTL.ControlStages SET StageName = 'Trusted to Curated' where ControlStageId = 3

  UPDATE CTL.ControlTasks SET LoadToSqlEDW = 1 WHERE LoadToSqlEDW IS NULL

  UPDATE CTL.ControlSource SET AdditionalProperty = '' WHERE AdditionalProperty IS NULL

GO

GO
PRINT N'Update complete.';


GO
