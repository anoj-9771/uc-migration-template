/*
Deployment script for ControlDB2

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "ControlDB2"
:setvar DefaultFilePrefix "ControlDB2"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating database $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE SQL_Latin1_General_CP1_CI_AS
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY FULL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET TEMPORAL_HISTORY_RETENTION ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Creating Schema [CTL]...';


GO
CREATE SCHEMA [CTL]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Table [CTL].[TaskExecutionLog]...';


GO
CREATE TABLE [CTL].[TaskExecutionLog] (
    [ExecutionLogId]   BIGINT         IDENTITY (1, 1) NOT NULL,
    [BatchExecutionId] BIGINT         NOT NULL,
    [ControlTaskId]    BIGINT         NOT NULL,
    [StartTime]        DATETIME       NOT NULL,
    [EndTime]          DATETIME       NULL,
    [ExecutionStatus]  VARCHAR (50)   NULL,
    [ErrorMessage]     VARCHAR (2000) NULL,
    [TaskOutput]       VARCHAR (2000) NULL,
    CONSTRAINT [PK_TaskExecutionLog] PRIMARY KEY CLUSTERED ([ExecutionLogId] ASC)
);


GO
PRINT N'Creating Table [CTL].[CustomDataLoad]...';


GO
CREATE TABLE [CTL].[CustomDataLoad] (
    [TableName]          VARCHAR (255) NULL,
    [ServiceName]        VARCHAR (255) NULL,
    [StartDate]          DATETIME      NULL,
    [EndDate]            DATETIME      NULL,
    [ExtractionComplete] BIT           NULL
);


GO
PRINT N'Creating Table [CTL].[ControlWatermark]...';


GO
CREATE TABLE [CTL].[ControlWatermark] (
    [WatermarkId]     BIGINT         IDENTITY (1, 1) NOT NULL,
    [ControlSourceId] BIGINT         NOT NULL,
    [SourceColumn]    VARCHAR (255)  NULL,
    [SourceSQL]       VARCHAR (2000) NOT NULL,
    [Watermarks]      VARCHAR (MAX)  NULL,
    [SourceName]      NVARCHAR (255) NULL,
    CONSTRAINT [PK_ControlWatermark] PRIMARY KEY CLUSTERED ([WatermarkId] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlTypes]...';


GO
CREATE TABLE [CTL].[ControlTypes] (
    [TypeId]      INT           IDENTITY (1, 1) NOT NULL,
    [ControlType] VARCHAR (255) NULL,
    CONSTRAINT [PK_ControlTypes] PRIMARY KEY CLUSTERED ([TypeId] ASC)
);


GO
PRINT N'Creating Index [CTL].[ControlTypes].[IX_ControlTypes_ControlType]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_ControlTypes_ControlType]
    ON [CTL].[ControlTypes]([ControlType] ASC);


GO
PRINT N'Creating Table [CTL].[ControlTasks]...';


GO
CREATE TABLE [CTL].[ControlTasks] (
    [TaskId]                       BIGINT        IDENTITY (1, 1) NOT NULL,
    [TaskName]                     VARCHAR (255) NOT NULL,
    [SourceId]                     BIGINT        NOT NULL,
    [TargetId]                     BIGINT        NOT NULL,
    [TruncateTarget]               BIT           NOT NULL,
    [TaskEnabled]                  BIT           NOT NULL,
    [LoadLatestOnly]               BIT           NOT NULL,
    [ExecuteSourceSQLasStoredProc] BIT           NOT NULL,
    [ControlStageId]               BIGINT        NOT NULL,
    [ProjectId]                    BIGINT        NULL,
    [ObjectGrain]                  VARCHAR (30)  NULL,
    [DataLoadMode]                 VARCHAR (100) NULL,
    [TrackChanges]                 BIT           NULL,
    [LoadToSqlEDW]                 BIT           NULL,
    CONSTRAINT [PK_ControlTasks] PRIMARY KEY CLUSTERED ([TaskId] ASC),
    CONSTRAINT [UQ_ControlTasks_TaskName] UNIQUE NONCLUSTERED ([TaskName] ASC, [ControlStageId] ASC, [ProjectId] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlTaskCommand]...';


GO
CREATE TABLE [CTL].[ControlTaskCommand] (
    [CommandId]     BIGINT        IDENTITY (1, 1) NOT NULL,
    [ControlTaskId] BIGINT        NOT NULL,
    [CommandTypeId] BIGINT        NOT NULL,
    [Command]       VARCHAR (MAX) NULL,
    CONSTRAINT [PK_ControlTaskCommand] PRIMARY KEY CLUSTERED ([CommandId] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlTargetColumns]...';


GO
CREATE TABLE [CTL].[ControlTargetColumns] (
    [ControlTargetColumnId] BIGINT        IDENTITY (1, 1) NOT NULL,
    [TargetId]              BIGINT        NOT NULL,
    [ColumnName]            VARCHAR (255) NOT NULL,
    [DataType]              VARCHAR (50)  NOT NULL,
    [MaxLength]             INT           NOT NULL,
    [Precision]             INT           NOT NULL,
    CONSTRAINT [PK_ControlTargetColumns] PRIMARY KEY CLUSTERED ([ControlTargetColumnId] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlTarget]...';


GO
CREATE TABLE [CTL].[ControlTarget] (
    [TargetId]       BIGINT         IDENTITY (1, 1) NOT NULL,
    [TargetName]     VARCHAR (255)  NOT NULL,
    [TargetTypeId]   INT            NOT NULL,
    [TargetLocation] VARCHAR (1000) NOT NULL,
    [TargetEnabled]  BIT            NULL,
    [Compressed]     BIT            NULL,
    [TargetServer]   VARCHAR (255)  NULL,
    CONSTRAINT [PK_ControlTarget] PRIMARY KEY CLUSTERED ([TargetId] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlStages]...';


GO
CREATE TABLE [CTL].[ControlStages] (
    [ControlStageId] BIGINT        IDENTITY (1, 1) NOT NULL,
    [StageSequence]  INT           NOT NULL,
    [StageName]      VARCHAR (100) NULL,
    CONSTRAINT [PK_ControlStages] PRIMARY KEY CLUSTERED ([ControlStageId] ASC)
);


GO
PRINT N'Creating Index [CTL].[ControlStages].[IX_ControlStages_StageSequence]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_ControlStages_StageSequence]
    ON [CTL].[ControlStages]([StageSequence] ASC);


GO
PRINT N'Creating Index [CTL].[ControlStages].[IX_ControlStages_StageName]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_ControlStages_StageName]
    ON [CTL].[ControlStages]([StageName] ASC);


GO
PRINT N'Creating Table [CTL].[ControlSourceColumns]...';


GO
CREATE TABLE [CTL].[ControlSourceColumns] (
    [ControlSourceColumnId] BIGINT         IDENTITY (1, 1) NOT NULL,
    [SourceTableId]         BIGINT         NOT NULL,
    [ColumnName]            VARCHAR (255)  NOT NULL,
    [DataType]              VARCHAR (50)   NOT NULL,
    [MaxLength]             INT            NOT NULL,
    [Precision]             INT            NOT NULL,
    [ColumnQuery]           VARCHAR (1000) NOT NULL,
    [SourceProcessor]       VARCHAR (255)  NULL,
    CONSTRAINT [PK_ControlSourceColumns] PRIMARY KEY CLUSTERED ([ControlSourceColumnId] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlSource]...';


GO
CREATE TABLE [CTL].[ControlSource] (
    [SourceId]           BIGINT         IDENTITY (1, 1) NOT NULL,
    [SourceName]         VARCHAR (255)  NOT NULL,
    [SourceTypeId]       INT            NOT NULL,
    [SourceLocation]     VARCHAR (1000) NOT NULL,
    [LoadSource]         BIT            NOT NULL,
    [SourceServer]       VARCHAR (255)  NULL,
    [Processor]          VARCHAR (255)  NULL,
    [BusinessKeyColumn]  VARCHAR (100)  NULL,
    [AdditionalProperty] VARCHAR (MAX)  NULL,
    [IsAuditTable]       BIT            NULL,
    [SoftDeleteSource]   VARCHAR (255)  NULL,
    [UseAuditTable]      BIT            NULL,
    [ValidationColumn]   VARCHAR (100)  NULL,
    CONSTRAINT [PK_ControlSource] PRIMARY KEY CLUSTERED ([SourceId] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlProjectSchedule]...';


GO
CREATE TABLE [CTL].[ControlProjectSchedule] (
    [ControlTaskScheduleId] BIGINT        IDENTITY (1, 1) NOT NULL,
    [ControlProjectId]      BIGINT        NOT NULL,
    [CronExpression]        VARCHAR (250) NULL,
    [ControlStageID]        INT           NULL,
    [TriggerName]           VARCHAR (100) NULL,
    CONSTRAINT [PK_ControlProjectSchedule] PRIMARY KEY CLUSTERED ([ControlTaskScheduleId] ASC)
);


GO
PRINT N'Creating Index [CTL].[ControlProjectSchedule].[IX_ControlProjectSchedule_Unique]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_ControlProjectSchedule_Unique]
    ON [CTL].[ControlProjectSchedule]([ControlProjectId] ASC, [ControlStageID] ASC, [TriggerName] ASC);


GO
PRINT N'Creating Table [CTL].[ControlProjects]...';


GO
CREATE TABLE [CTL].[ControlProjects] (
    [ProjectId]   BIGINT        IDENTITY (1, 1) NOT NULL,
    [ProjectName] VARCHAR (255) NOT NULL,
    [Enabled]     BIT           NULL,
    CONSTRAINT [PK_ControlProjects] PRIMARY KEY CLUSTERED ([ProjectId] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlManifest]...';


GO
CREATE TABLE [CTL].[ControlManifest] (
    [BatchExecutionLogID]      BIGINT         NOT NULL,
    [TaskExecutionLogID]       BIGINT         NOT NULL,
    [SourceObject]             VARCHAR (1000) NULL,
    [Container]                VARCHAR (1000) NULL,
    [StartCounter]             VARCHAR (500)  NULL,
    [EndCounter]               VARCHAR (500)  NULL,
    [RecordCountLoaded]        BIGINT         NULL,
    [RecordCountDeltaTable]    BIGINT         NULL,
    [FolderName]               VARCHAR (1000) NULL,
    [FileName]                 VARCHAR (1000) NULL,
    [ProcessedToTrustedZone]   BIT            NULL,
    [DeltaColumn]              NVARCHAR (100) NULL,
    [ProcessedToSQLEDW]        BIT            NULL,
    [RawZonePipelineRunID]     VARCHAR (50)   NULL,
    [TrustedZonePipelineRunID] VARCHAR (50)   NULL,
    [SQLEDWPipelineRunID]      VARCHAR (50)   NULL,
    CONSTRAINT [PK_CTL_ControlManifest] PRIMARY KEY CLUSTERED ([BatchExecutionLogID] ASC, [TaskExecutionLogID] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlDataLoadValidation]...';


GO
CREATE TABLE [CTL].[ControlDataLoadValidation] (
    [DataValidationID]    BIGINT        IDENTITY (1, 1) NOT NULL,
    [ProjectRunID]        VARCHAR (50)  NOT NULL,
    [ObjectName]          VARCHAR (255) NULL,
    [SourceHighWatermark] VARCHAR (100) NULL,
    [SourceRecordCount]   BIGINT        NULL,
    [SourceTotalValue]    BIGINT        NULL,
    [SourceMinValue]      BIGINT        NULL,
    [SourceMaxValue]      BIGINT        NULL,
    [TargetHighWatermark] VARCHAR (100) NULL,
    [TargetRecordCount]   BIGINT        NULL,
    [TargetTotalValue]    BIGINT        NULL,
    [TargetMinValue]      BIGINT        NULL,
    [TargetMaxValue]      BIGINT        NULL
);


GO
PRINT N'Creating Table [CTL].[ControlDataLoadTypes]...';


GO
CREATE TABLE [CTL].[ControlDataLoadTypes] (
    [DataLoadTypeID] INT           IDENTITY (1, 1) NOT NULL,
    [DataLoadType]   NVARCHAR (50) NOT NULL,
    [DeltaExtract]   BIT           NOT NULL,
    [CDCSource]      BIT           NOT NULL,
    [TruncateTarget] BIT           NOT NULL,
    [UpsertTarget]   BIT           NOT NULL,
    CONSTRAINT [PK_ControlDataLoadTypes] PRIMARY KEY CLUSTERED ([DataLoadTypeID] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlCuratedManifest]...';


GO
CREATE TABLE [CTL].[ControlCuratedManifest] (
    [BatchExecutionLogID] BIGINT        NOT NULL,
    [TaskExecutionLogID]  BIGINT        NOT NULL,
    [SubjectArea]         VARCHAR (255) NOT NULL,
    [Project]             VARCHAR (255) NOT NULL,
    [StartPeriod]         DATETIME      NULL,
    [EndPeriod]           DATETIME      NULL,
    [LoadStatus]          VARCHAR (100) NULL,
    [StartTimestamp]      DATETIME      NULL,
    [EndTimeStamp]        DATETIME      NULL,
    CONSTRAINT [PK_ControlCuratedManifest] PRIMARY KEY CLUSTERED ([BatchExecutionLogID] ASC, [TaskExecutionLogID] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlCuratedConfig]...';


GO
CREATE TABLE [CTL].[ControlCuratedConfig] (
    [SubjectArea]        VARCHAR (255) NOT NULL,
    [Project]            VARCHAR (255) NOT NULL,
    [DependentTableName] VARCHAR (255) NOT NULL,
    [Valid]              BIT           NOT NULL,
    CONSTRAINT [PK_ControlCuratedConfig] PRIMARY KEY CLUSTERED ([SubjectArea] ASC, [Project] ASC, [DependentTableName] ASC)
);


GO
PRINT N'Creating Table [CTL].[ControlComplianceDependency]...';


GO
CREATE TABLE [CTL].[ControlComplianceDependency] (
    [TableName] VARCHAR (255) NULL
);


GO
PRINT N'Creating Table [CTL].[Configuration]...';


GO
CREATE TABLE [CTL].[Configuration] (
    [ConfigurationKey]   VARCHAR (255) NOT NULL,
    [ConfigurationValue] VARCHAR (255) NOT NULL
);


GO
PRINT N'Creating Table [CTL].[BatchExecutionLog]...';


GO
CREATE TABLE [CTL].[BatchExecutionLog] (
    [BatchExecutionLogId]  BIGINT         IDENTITY (1, 1) NOT NULL,
    [StartDate]            DATETIME       NOT NULL,
    [EndDate]              DATETIME       NULL,
    [BatchExecutionStatus] VARCHAR (50)   NOT NULL,
    [ErrorMessage]         VARCHAR (2000) NULL,
    [ProjectID]            BIGINT         NULL,
    CONSTRAINT [PK_BatchExecutionLog] PRIMARY KEY CLUSTERED ([BatchExecutionLogId] ASC)
);


GO
PRINT N'Creating Foreign Key [CTL].[FK_TaskExecutionLog_BatchExecutionLog]...';


GO
ALTER TABLE [CTL].[TaskExecutionLog]
    ADD CONSTRAINT [FK_TaskExecutionLog_BatchExecutionLog] FOREIGN KEY ([BatchExecutionId]) REFERENCES [CTL].[BatchExecutionLog] ([BatchExecutionLogId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_TaskExecutionLog_ControlTasks]...';


GO
ALTER TABLE [CTL].[TaskExecutionLog]
    ADD CONSTRAINT [FK_TaskExecutionLog_ControlTasks] FOREIGN KEY ([ControlTaskId]) REFERENCES [CTL].[ControlTasks] ([TaskId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_ControlWatermark_ControlSource]...';


GO
ALTER TABLE [CTL].[ControlWatermark]
    ADD CONSTRAINT [FK_ControlWatermark_ControlSource] FOREIGN KEY ([ControlSourceId]) REFERENCES [CTL].[ControlSource] ([SourceId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_ControlTasks_ControlSource]...';


GO
ALTER TABLE [CTL].[ControlTasks]
    ADD CONSTRAINT [FK_ControlTasks_ControlSource] FOREIGN KEY ([SourceId]) REFERENCES [CTL].[ControlSource] ([SourceId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_ControlTasks_ControlStages]...';


GO
ALTER TABLE [CTL].[ControlTasks]
    ADD CONSTRAINT [FK_ControlTasks_ControlStages] FOREIGN KEY ([ControlStageId]) REFERENCES [CTL].[ControlStages] ([ControlStageId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_ControlTasks_ControlTarget]...';


GO
ALTER TABLE [CTL].[ControlTasks]
    ADD CONSTRAINT [FK_ControlTasks_ControlTarget] FOREIGN KEY ([TargetId]) REFERENCES [CTL].[ControlTarget] ([TargetId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_ControlTaskCommand_ControlTasks]...';


GO
ALTER TABLE [CTL].[ControlTaskCommand]
    ADD CONSTRAINT [FK_ControlTaskCommand_ControlTasks] FOREIGN KEY ([ControlTaskId]) REFERENCES [CTL].[ControlTasks] ([TaskId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_ControlTargetColumns_ControlTarget]...';


GO
ALTER TABLE [CTL].[ControlTargetColumns]
    ADD CONSTRAINT [FK_ControlTargetColumns_ControlTarget] FOREIGN KEY ([TargetId]) REFERENCES [CTL].[ControlTarget] ([TargetId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_ControlTarget_ControlTypes]...';


GO
ALTER TABLE [CTL].[ControlTarget]
    ADD CONSTRAINT [FK_ControlTarget_ControlTypes] FOREIGN KEY ([TargetTypeId]) REFERENCES [CTL].[ControlTypes] ([TypeId]);


GO
PRINT N'Creating Foreign Key [CTL].[FK_ControlSource_ControlTypes]...';


GO
ALTER TABLE [CTL].[ControlSource]
    ADD CONSTRAINT [FK_ControlSource_ControlTypes] FOREIGN KEY ([SourceTypeId]) REFERENCES [CTL].[ControlTypes] ([TypeId]);


GO
PRINT N'Creating View [CTL].[vw_TaskExecutionDetails]...';


GO

CREATE VIEW [CTL].[vw_TaskExecutionDetails]
AS

SELECT [ExecutionLogId]
      ,[BatchExecutionId]
      ,[ControlTaskId]
	  ,p.ProjectName
	  ,p.ProjectId
	  ,s.ControlStageId as StageId
	  ,s.StageName
	  ,t.TaskName
      ,[StartTime]
      ,[EndTime]
	  ,DATEDIFF(MINUTE,StartTime,EndTime) as Duration
      ,[ExecutionStatus]
      ,[ErrorMessage]
      ,[TaskOutput]
  FROM [CTL].[TaskExecutionLog] as l
  left join [CTL].[ControlTasks] as t 
  on l.ControlTaskId = t.TaskId
  left join [CTL].[ControlStages] as s
  on t.ControlStageId = s.ControlStageId
  left join [CTL].[ControlProjects] as p
  on t.ProjectId = p.ProjectId
  --order by BatchExecutionId desc, StartTime desc--, ExecutionStatus, duration desc
GO
PRINT N'Creating View [CTL].[vw_ControlConfiguration]...';


GO






CREATE VIEW [CTL].[vw_ControlConfiguration]
AS
SELECT 
	TaskName 
	,ProjectName
	,DataLoadMode
	,BusinessKeyColumn 
	,TYPES.ControlType
	,TASKS.ControlStageId
	,TrackChanges
	,SourceLocation
	,TargetLocation
	,TaskEnabled
	,S.SourceServer
	,AdditionalProperty
	,Command
	,W.SourceColumn
	,W.Watermarks
	,S.Processor
	,S.SoftDeleteSource
	,S.IsAuditTable
	,TASKS.TaskId
	,S.SourceId
	,TGT.TargetId
	,P.ProjectId
FROM CTL.ControlTasks TASKS
INNER JOIN CTL.ControlSource S ON TASKS.SourceId = S.SourceId
INNER JOIN CTL.ControlTarget TGT ON TASKS.TargetId = TGT.TargetId
INNER JOIN CTL.ControlProjects P ON TASKS.ProjectId = P.ProjectId
INNER JOIN CTL.ControlTypes TYPES ON S.SourceTypeId = TYPES.TypeId
LEFT JOIN CTL.ControlTaskCommand CTC ON Tasks.TaskId = CTC.ControlTaskId
LEFT JOIN CTL.ControlWatermark W ON W.ControlSourceId = S.SourceId
GO
PRINT N'Creating Function [CTL].[udf_GetWAustDateTime]...';


GO
CREATE FUNCTION CTL.udf_GetWAustDateTime(@d as datetime)
returns DATETIME
as
begin
     DECLARE @DT AS datetimeoffset

     SET @DT = CONVERT(datetimeoffset, @d) AT TIME ZONE 'W. Australia Standard Time'

     RETURN CONVERT(datetime, @DT);

end
GO
PRINT N'Creating Function [CTL].[udf_GetNZDateTime]...';


GO
CREATE FUNCTION CTL.udf_GetNZDateTime(@d as datetime)
returns DATETIME
as
begin
     DECLARE @DT AS datetimeoffset

     SET @DT = CONVERT(datetimeoffset, @d) AT TIME ZONE 'New Zealand Standard Time'

     RETURN CONVERT(datetime, @DT);

end
GO
PRINT N'Creating Function [CTL].[udf_GetMultiColTableJoinClause]...';


GO
CREATE FUNCTION [CTL].[udf_GetMultiColTableJoinClause] (
	@Column varchar(255),
	@SourceAlias varchar(100),
	@TargetAlias varchar(100)
)
RETURNS VARCHAR(MAX)
AS
/**************************************************************
This function returns the column list with the source and target table alias for table join
**************************************************************/
BEGIN

	DECLARE @SQLClause VARCHAR(MAX) = ''

	IF CHARINDEX (',', @Column) > 0
	BEGIN
		--Temporary table to store the list of columns 	
		DECLARE @ColTable TABLE 
		(
			ColName varchar(100),
			RowID INT identity(1,1)
		)

		--Split the column list based on comma and store in the temporary table
		INSERT INTO @ColTable (ColName)
		SELECT VALUE FROM STRING_SPLIT(@Column, ',')

		DECLARE @TotalRows INT, @CurrentRow INT

		--Get the total number of rows
		SELECT @TotalRows = COUNT(1) FROM @ColTable

		--Initial Counter
		SET @CurrentRow = 1

		--Loop through all the records
		WHILE @CurrentRow <= @TotalRows
		BEGIN
			DECLARE @Row varchar(100), @CurrentCol varchar(100)
			SELECT @CurrentCol = ColName FROM @ColTable WHERE RowID = @CurrentRow
			SET @CurrentCol = TRIM(@CurrentCol)
			--Alias the columns
			SET @Row = @SourceAlias + '.' + @CurrentCol + ' = ' + @TargetAlias + '.' + @CurrentCol

			--Add the and clause from the second part onwards
			IF @SQLClause = ''
				SET @SQLClause = @SQLClause + @Row
			ELSE
				SET @SQLClause = @SQLClause + ' AND ' + @Row

			--Increment the counter, so that we are not in infinite loop
			SET @CurrentRow = @CurrentRow + 1
		END
	END
	ELSE
	BEGIN
		--If there are no comma, it means there is only one column
		SET @SQLClause = @SourceAlias + '.' + @Column + ' = ' + @TargetAlias + '.' + @Column
	END
	RETURN @SQLClause

END
GO
PRINT N'Creating Function [CTL].[udf_GetMultiColSelectList]...';


GO
CREATE FUNCTION [CTL].[udf_GetMultiColSelectList] (
	@Column varchar(255),
	@SourceAlias varchar(100)
)
RETURNS VARCHAR(MAX)
AS
/**************************************************************
This function returns the column list with the source alias for select list
**************************************************************/
BEGIN

	DECLARE @SQLClause VARCHAR(MAX) = ''

	IF CHARINDEX (',', @Column) > 0
	BEGIN
		--Temporary table to store the list of columns 	
		DECLARE @ColTable TABLE 
		(
			ColName varchar(100),
			RowID INT identity(1,1)
		)

		--Split the column list based on comma and store in the temporary table
		INSERT INTO @ColTable (ColName)
		SELECT VALUE FROM STRING_SPLIT(@Column, ',')

		DECLARE @TotalRows INT, @CurrentRow INT

		--Get the total number of rows
		SELECT @TotalRows = COUNT(1) FROM @ColTable

		--Initial Counter
		SET @CurrentRow = 1

		--Loop through all the records
		WHILE @CurrentRow <= @TotalRows
		BEGIN
			DECLARE @Row varchar(100), @CurrentCol varchar(100)
			SELECT @CurrentCol = ColName FROM @ColTable WHERE RowID = @CurrentRow
			SET @CurrentCol = TRIM(@CurrentCol)
			--Alias the columns
			SET @Row = @SourceAlias + '.' + @CurrentCol

			--Add the comma from the second part onwards
			IF @SQLClause = ''
				SET @SQLClause = @SQLClause + @Row
			ELSE
				SET @SQLClause = @SQLClause + ', ' + @Row

			--Increment the counter, so that we are not in infinite loop
			SET @CurrentRow = @CurrentRow + 1
		END
	END
	ELSE
	BEGIN
		--If there are no comma, it means there is only one column
		SET @SQLClause = @SourceAlias + '.' + @Column 
	END
	RETURN @SQLClause

END
GO
PRINT N'Creating Function [CTL].[udf_GetMultiColFilterClause]...';


GO
CREATE FUNCTION [CTL].[udf_GetMultiColFilterClause] (
	@Column varchar(255),
	@SourceType varchar(100)
)
Returns Varchar(MAX)
AS
/**************************************************************
This function returns the filter condition for null handling of more than one column
**************************************************************/
BEGIN

DECLARE @COL VARCHAR(255)

IF CHARINDEX (',', @Column) > 0
BEGIN
	IF @SourceType = 'SQL Server'
		SET @COL = 'COALESCE (' + @Column + ')'
	ELSE IF @SourceType = 'Oracle'
		SET @COL = 'COALESCE (' + @Column + ')'
	ELSE
		SET @COL = @Column
END
ELSE
	SET @COL = @Column

RETURN @COL
END
GO
PRINT N'Creating Function [CTL].[udf_GetLastLoadedFile]...';


GO
CREATE Function [CTL].[udf_GetLastLoadedFile] (@SourceName Varchar(255), @SourceLocation Varchar(255))
Returns Varchar(255)
As
BEGIN
	Declare @File Varchar(255) = ''
	Select @File = (
		select a.TaskOutput from (
			Select l.TaskOutput, TargetName, TargetLocation, row_number()over(order by l.TaskOutput desc) RowNum
			  From CTL.ControlTarget targ
				Join CTL.ControlTasks t
				  On targ.TargetId = t.TargetId
				Join CTL.TaskExecutionLog l
				  On t.TaskId = l.ControlTaskId
				 And l.ExecutionStatus = 'Success'
				 And l.EndTime = (Select Max(EndTime)
									From CTL.TaskExecutionLog
								   Where ControlTaskId = t.TaskId)
				And targ.TargetName = @SourceName
	            And targ.TargetLocation = @SourceLocation
			)a where a.RowNum = 1)
	   --And a.TargetName = @SourceName
	   --And a.TargetLocation = @SourceLocation)

	Return @File
END
GO
PRINT N'Creating Function [CTL].[udf_GetEAustDateTime]...';


GO
CREATE FUNCTION [CTL].[udf_GetEAustDateTime](@d as datetime)
returns DATETIME
as
begin
     DECLARE @DT AS datetimeoffset

     SET @DT = CONVERT(datetimeoffset, @d) AT TIME ZONE 'E. Australia Standard Time'

     RETURN CONVERT(datetime, @DT);

end
GO
PRINT N'Creating Function [CTL].[udf_GetDeltaSQL]...';


GO
CREATE FUNCTION [CTL].[udf_GetDeltaSQL] (@TaskId BigInt)
Returns Varchar(MAX)
AS
/************************************************************
The function builds the initial SQL for Source Extraction
The function is called from the SP [CTL].[GetExecutionTasks] while building initial TaskDetails

************************************************************/

BEGIN
	Declare @SQL Varchar(Max) = 'SELECT * ',
			@TableName Varchar(255) = '',
			@WHERE Varchar(2000) = ' WHERE 1 = 1 '

	DECLARE @DataLoadMode varchar(100)
	DECLARE @SourceType varchar(100)
	DECLARE @IsAuditTable bit, @UseAuditTable bit
	DECLARE @TaskName varchar(100)
	DECLARE @AuditTable varchar(100)
	DECLARE @SQLCommand varchar(max)
	DECLARE @WaterMarkCol varchar(100), @WatermarkVal varchar(40)
	DECLARE @BusinessKey varchar(100)

	--This keyword will be inserted in the current delta sql and will be replaced with endvalue in ADF
	DECLARE @EndDateKey varchar(100) = '<<ENDDATE>>'

	--Get values from table
	SELECT 
		@DataLoadMode = CT.DataLoadMode 
		,@SourceType = T.ControlType
		,@TableName = CS.SourceLocation
		,@IsAuditTable = CS.IsAuditTable
		,@UseAuditTable = CS.UseAuditTable
		,@TaskName = CT.TaskName
		,@AuditTable = CS.SoftDeleteSource
		,@SQLCommand = CTC.Command
		,@WaterMarkCol = WM.SourceColumn
		,@WatermarkVal = WM.Watermarks
		,@BusinessKey = CS.BusinessKeyColumn
	FROM CTL.ControlTasks CT 
	LEFT JOIN CTL.ControlSource CS ON CT.SourceId = CS.SourceId
	LEFT JOIN CTL.ControlTypes T ON CS.SourceTypeId = T.TypeId
	LEFT JOIN CTL.ControlTaskCommand CTC ON CT.TaskId = CTC.ControlTaskId
	LEFT JOIN CTL.ControlWatermark WM ON CS.SourceId = WM.ControlSourceId
	WHERE CT.TaskId = @TaskId

	SET @SQLCommand = (SELECT Command FROM CTL.ControlTaskCommand WHERE ControlTaskId = @TaskId)

	--Beginning of filter condition build block

	/**********************************************************************/
	--Start of Special Audit Table Handling of OneEBS
	IF @UseAuditTable = 1 AND @AuditTable <> '' AND @TaskName LIKE 'OneEBS%'
	BEGIN
		DECLARE @ALIAS_MAIN varchar(50) = 'mn'
		DECLARE @ALIAS_AUDIT varchar(50) = 'aud'
		DECLARE @ALIAS_UPDATED_TRANS_DATE varchar(50) = '"_ONEEBS_UPDATED_TRANSACTION_DATE"' --Please ensure that this column name is used as in on DataBricks
		DECLARE @JOIN_CLAUSE VARCHAR(500), @WATERMARK_COLS VARCHAR(500)

		--Get the table join clause with columns aliased
		SET @JOIN_CLAUSE = [CTL].[udf_GetMultiColTableJoinClause](@BusinessKey, @ALIAS_MAIN, @ALIAS_AUDIT)

		--Get the SQL Column list with columns aliased
		SET @WATERMARK_COLS = [CTL].[udf_GetMultiColSelectList](@WaterMarkCol, @ALIAS_MAIN)


		SET @SQL = 'SELECT '
		SET @SQL = @SQL + @ALIAS_MAIN + '.*'
		SET @SQL = @SQL + ', COALESCE(' + @ALIAS_AUDIT + '.AUDIT__TIMESTAMP, ' + @WATERMARK_COLS + ') ' + @ALIAS_UPDATED_TRANS_DATE
		SET @SQL = @SQL + ' FROM ' + @TableName + ' ' + @ALIAS_MAIN
		SET @SQL = @SQL + ' LEFT JOIN ('
		SET @SQL = @SQL + ' SELECT ' + @BusinessKey + ', MAX(AUDIT__TIMESTAMP) AS AUDIT__TIMESTAMP'
		SET @SQL = @SQL + ' FROM ' + @AuditTable
		SET @SQL = @SQL + ' WHERE AUDIT__TIMESTAMP'
		SET @SQL = @SQL + ' BETWEEN TO_DATE(''' + @WatermarkVal + ''', ''YYYY-MM-DD HH24:MI:SS'') AND TO_DATE(''' + @EndDateKey + ''', ''YYYY-MM-DD HH24:MI:SS'')'
		SET @SQL = @SQL + ' GROUP BY ' + @BusinessKey
		SET @SQL = @SQL + ' ) ' + @ALIAS_AUDIT + ' ON ' + @JOIN_CLAUSE
		SET @SQL = @SQL + ' WHERE COALESCE(' + @ALIAS_AUDIT + '.AUDIT__TIMESTAMP, ' + @WATERMARK_COLS + ')'
		SET @SQL = @SQL + ' BETWEEN TO_DATE(''' + @WatermarkVal + ''', ''YYYY-MM-DD HH24:MI:SS'') AND TO_DATE(''' + @EndDateKey + ''', ''YYYY-MM-DD HH24:MI:SS'')'

		RETURN @SQL

	END
	--End of Special Audit Table Handling of OneEBS
	/**********************************************************************/

	--Start of normal incrmental block. This is needed to build the WHERE Clause for Source Extraction
	--The following section checks if the source type is CDC. Use a different block altogether for CDC
	IF @DataLoadMode = 'CDC'
	BEGIN
	
			SELECT @TableName = @TableName + '[CDC].[' + (Select SourceName 
				FROM CTL.ControlTasks CT
				INNER JOIN CTL.ControlSource CS ON CT.SourceId = CS.SourceId
				WHERE CT.TaskId = @TaskId) + '_ct]'

			SET @WHERE = @WHERE + ' UPPER([__$start_lsn]) > CONVERT(BINARY(10), ''' + @WatermarkVal + ''', 1) AND [__$operation] in (1, 2, 3, 4)'

	--End of CDC block
	END
	ELSE IF @DataLoadMode IN ('INCREMENTAL', 'APPEND')
	BEGIN
		--If it is Audit table and from OneEBS than update the source sql to include only deleted records
		IF @IsAuditTable = 1 AND @TaskName LIKE 'OneEBSAudit%'
		BEGIN
			SET @WHERE = @WHERE + ' AND AUDIT__OPERATION = ''D'' '
		END

		SET @WaterMarkCol = [CTL].[udf_GetMultiColFilterClause](@WaterMarkCol, @SourceType)
		IF @SourceType = 'Oracle'
			Select @WHERE = @WHERE  + ' AND ' + @WaterMarkCol + ' BETWEEN TO_DATE(''' + @WatermarkVal + ''', ''YYYY-MM-DD HH24:MI:SS'') AND TO_DATE(''' + @EndDateKey + ''', ''YYYY-MM-DD HH24:MI:SS'')'
		ELSE
			Select @WHERE = @WHERE  + ' AND ' + @WaterMarkCol + ' BETWEEN ''' + @WatermarkVal + ''' AND ''' + @EndDateKey + ''
	END
	ELSE
	BEGIN
		--If it is Full-Extract or Truncate-Load then we do not need the WHERE Clause
		SELECT @WHERE = ''
	END
	--End of normal incrmental block


	/**************FINAL SQL****************************/
	--If the Configuration defines the SQL Extraction Column use that, else use SELECT * to pick all columns from Source Table
	IF UPPER(LEFT(TRIM(@SQLCommand), 8)) = 'SELECT *'
		SET @SQL = @SQL + 'FROM ' + @TableName
	ELSE
		SET @SQL = @SQLCommand

	--Build the final SQL with the WHERE filter clause
	SET @SQL = @SQL + @WHERE

	--Return the SQL
	Return @SQL 
END
GO
PRINT N'Creating Function [CTL].[udf_GetDateLocalTZ]...';


GO
CREATE FUNCTION [CTL].[udf_GetDateLocalTZ]()
returns DATETIME
as
begin
     DECLARE @DT AS datetimeoffset

     SET @DT = CONVERT(datetimeoffset, GETDATE()) AT TIME ZONE 'AUS Eastern Standard Time'

     RETURN CONVERT(datetime, @DT);

end
GO
PRINT N'Creating Function [CTL].[getLastLoadedFile]...';


GO
CREATE Function [CTL].[getLastLoadedFile] (@SourceName Varchar(255), @SourceLocation Varchar(255))
Returns Varchar(255)
As
BEGIN
	Declare @File Varchar(255) = ''
	Select @File = (
		select a.TaskOutput from (
			Select l.TaskOutput, TargetName, TargetLocation, row_number()over(order by l.TaskOutput desc) RowNum
			  From CTL.ControlTarget targ
				Join CTL.ControlTasks t
				  On targ.TargetId = t.TargetId
				Join CTL.TaskExecutionLog l
				  On t.TaskId = l.ControlTaskId
				 And l.ExecutionStatus = 'Success'
				 And l.EndTime = (Select Max(EndTime)
									From CTL.TaskExecutionLog
								   Where ControlTaskId = t.TaskId)
				And targ.TargetName = @SourceName
	            And targ.TargetLocation = @SourceLocation
			)a where a.RowNum = 1)
	   --And a.TargetName = @SourceName
	   --And a.TargetLocation = @SourceLocation)

	Return @File
END
GO
PRINT N'Creating Function [CTL].[GetDeltaSQL]...';


GO
CREATE FUNCTION [CTL].[GetDeltaSQL] (@TaskId BigInt)
Returns Varchar(MAX)
AS
BEGIN
Declare @SQL Varchar(Max) = 'Select * ',
		@TableName Varchar(255) = ' From ',
		@Where Varchar(2000) = ' Where '

Declare @Columns Table
(
  ColumnName Varchar(255),
  SourceSQL Varchar(2000)
)

Declare @Watermakrs Table
(
  Watermark Varchar(255)
)

If (Select Count(*)
      From [CTL].[ControlSourceColumns] col
        Join [CTL].[ControlSource] cs
          On col.SourceTableId = cs.SourceId
        Join [CTL].[ControlTasks] ct
          On cs.SourceId = ct.SourceId
     Where ct.TaskId = @TaskId) = 0
  BEGIN
    Select @SQL = 'Select * '
  END
Else
  BEGIN
    Select @SQL = 'Select '
    Select @SQL = @SQL + Case When Len(col.ColumnQuery) = 0 then col.ColumnName else col.ColumnQuery end + ', '
      From [CTL].[ControlSourceColumns] col
        Join [CTL].[ControlSource] cs
          On col.SourceTableId = cs.SourceId
        Join [CTL].ControlTasks ct
          On cs.SourceId = ct.SourceId
     Where ct.TaskId = @TaskId
    Select @SQL = Left(@SQL, Len(@SQL) - 1)
  END

	Select @TableName = @TableName + (Select SourceLocation From CTL.ControlSource cs Join CTL.ControlTasks ct ON cs.SourceId = ct.SourceId  Where ct.TaskId = @TaskId)

	Insert Into @Columns
		Select m.SourceColumn, m.SourceSQL
			From [CTL].[ControlWatermark] m
				Join [CTL].[ControlSource] cs
				On m.ControlSourceId = cs.SourceId
			Join [CTL].[ControlTasks] ct
				On cs.SourceId = ct.SourceId
			Where ct.TaskId = @TaskId

	Insert Into @Watermakrs
	Select value
	  From string_split((
					Select m.Watermarks
					  From [CTL].[ControlWatermark] m
					    Join [CTL].[ControlSource] cs
						  On m.ControlSourceId = cs.SourceId
						Join [CTL].[ControlTasks] ct
						  On cs.SourceId = ct.SourceId
					 Where ct.TaskId = @TaskId), '|')

	While (Select Count(*) From @Columns) > 0
	  BEGIN
		--Updated by Rahul Agrawal on 28-Jan-2020. Updated the condition to > from >=. The >= operator loads the last watermark data over and over.
		Select @Where = @Where  + (Select Top 1 SourceSQL From @Columns) + ' > ''' + (Select Top 1 Watermark From @Watermakrs) + ''' AND '
		Delete Top(1) From @Columns
		Delete Top(1) From @Watermakrs
	  END

	Select @Where = LEFT(@Where, Len(@Where) - 4)

	Select @SQL = @SQL + @TableName + @Where

	Return @SQL 
END
GO
PRINT N'Creating Function [CTL].[udf_GetFileDateHierarchy]...';


GO




CREATE   FUNCTION [CTL].[udf_GetFileDateHierarchy] (@Grain varchar(20))
RETURNS varchar(50)
AS
BEGIN

return
(
	select Case @Grain
				WHEN 'Day' then 
					concat(
						'year=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'yyyy'), '/',
						'month=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'MM'), '/',
						'day=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'dd')
					)
				WHEN 'Month' then 
					concat(
						'year=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'yyyy'), '/',
						'month=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'MM'), '/'
					)
				WHEN 'Year' then 
					concat(
						'year=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'yyyy'), '/'
					)
				WHEN 'Hour' then 
					concat(
						'year=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'yyyy'), '/',
						'month=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'MM'), '/',
						'day=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'dd'), '/',
						'hour=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'HH')
					)
				WHEN 'Minute' then 
					concat(
						'year=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'yyyy'), '/',
						'month=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'MM'), '/',
						'day=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'dd'), '/',
						'hour=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'HH'), '/',
						'minute=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'mm')
					)
				WHEN 'Second' then 
					concat(
						'year=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'yyyy'), '/',
						'month=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'MM'), '/',
						'day=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'dd'), '/',
						'hour=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'HH'), '/',
						'minute=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'mm'), '/',
						'second=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'ss')
					)
				ELSE 
					concat(
						'year=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'yyyy'), '/',
						'month=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'MM'), '/',
						'day=',FORMAT([CTL].[udf_GetDateLocalTZ](),N'dd')
					)
		   End
)


END
GO
PRINT N'Creating Function [CTL].[udf_DelimitedSplit8K]...';


GO
CREATE FUNCTION [CTL].[udf_DelimitedSplit8K]
--===== Define I/O parameters
        (@pString VARCHAR(8000), @pDelimiter CHAR(1))
--WARNING!!! DO NOT USE MAX DATA-TYPES HERE!  IT WILL KILL PERFORMANCE!
RETURNS TABLE WITH SCHEMABINDING AS
 RETURN
--===== "Inline" CTE Driven "Tally Table" produces values from 1 up to 10,000...
     -- enough to cover VARCHAR(8000)
  WITH E1(N) AS (
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1
                ),                          --10E+1 or 10 rows
       E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows
       E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max
 cteTally(N) AS (--==== This provides the "base" CTE and limits the number of rows right up front
                     -- for both a performance gain and prevention of accidental "overruns"
                 SELECT TOP (ISNULL(DATALENGTH(@pString),0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4
                ),
cteStart(N1) AS (--==== This returns N+1 (starting position of each "element" just once for each delimiter)
                 SELECT 1 UNION ALL
                 SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@pString,t.N,1) = @pDelimiter
                ),
cteLen(N1,L1) AS(--==== Return start and length (for use in substring)
                 SELECT s.N1,
                        ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,8000)
                   FROM cteStart s
                )
--===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found.
 SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1),
        Item       = SUBSTRING(@pString, l.N1, l.L1)
   FROM cteLen l
;
GO
PRINT N'Creating Function [CTL].[udf_CronToDatetime]...';


GO
CREATE FUNCTION [CTL].[udf_CronToDatetime](@CRONExp varchar(50))
returns datetime2
as 
begin
	return (
		select cast(concat(Year,'/',Month,'/',DayOfMonth,' ',Hours,':',Minutes,':',Seconds) as datetime2)
		from (
			select 
				--Account for * and numeric seconds
				case when isNumeric(seconds) = 1
					then RIGHT('0'+ISNULL(Seconds,''),2)
					when isNumeric(Seconds) = 0 and Seconds = '*'
					then format([CTL].[fn_getWAustDateTime](getdate ()), 'ss')
					--Add for /
				end Seconds,
				case when isNumeric(Minutes) = 1
					then RIGHT('0'+ISNULL(Minutes,''),2)
					when isNumeric(Minutes) = 0 and Minutes = '*'
					then format([CTL].[fn_getWAustDateTime](getdate ()), 'mm')
					--Add for - /
				end Minutes,
				case when isNumeric(Hours) = 1
					then RIGHT('0'+ISNULL(Hours,''),2)
					when isNumeric(Hours) = 0 and Hours = '*'
					then format([CTL].[fn_getWAustDateTime](getdate ()), 'HH')
					--Add for - /
				end Hours,
				case when isNumeric(DayOfMonth) = 1
					then RIGHT('0'+ISNULL(DayOfMonth,''),2)
					when isNumeric(DayOfMonth) = 0 and DayOfMonth = '*'
					then datepart(dd,[CTL].[fn_getWAustDateTime](getdate ()))
					--Add for , - ? / L W
				end DayOfMonth,
				case when isNumeric(Month) = 1
					then RIGHT('0'+ISNULL(Month,''),2)
					when isNumeric(Month) = 0 and Month = '*'
					then datepart(mm,[CTL].[fn_getWAustDateTime](getdate ()))
					--Add for , - /
				end Month,
				case when isNumeric(DayOfWeek) = 1
					then RIGHT('0'+ISNULL(DayOfWeek,''),2)
					when isNumeric(DayOfWeek) = 0 and DayOfWeek = '*'
					then datepart(dw,[CTL].[fn_getWAustDateTime](getdate ()))
					--Add for , - /
				end DayOfWeek,
				case when isNumeric(Year) = 1
					then RIGHT('0'+ISNULL(Year,''),2)
					when isNumeric(Year) = 0 and (Year = '*' or Year is null) 
					then datepart(yyyy,[CTL].[fn_getWAustDateTime](getdate ()))
					--Add for , - /
				end Year
			from (
				select [1] Seconds , [2] Minutes , [3] Hours , [4] DayOfMonth, [5] Month, [6] DayOfWeek, [7] Year
				from (
						SELECT ItemNumber, Item
						FROM [CTL].[udf_DelimitedSplit8K](@CRONExp, ' ') 
					)a
					PIVOT
				(
					MAX(Item)
					FOR ItemNumber IN
						([1], [2], [3], [4], [5], [6], [7])
				) piv
			)a
		)b
	)
end
GO
PRINT N'Creating Function [CTL].[udf_CronToFrequency]...';


GO
CREATE FUNCTION [CTL].[udf_CronToFrequency](@CRONExp varchar(50))
returns varchar(50)
as 
begin
	return (
		select RunFrequency
		from (
			select 
				--Hierarchy for yyyy/
				case when seconds <> '*' 
					and Minutes <> '*' 
					and Hours <> '*' 
					and DayOfMonth <> '*' 
					and Month <> '*' 
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/')
				--Hierarchy for yyyy/MM/
				when seconds <> '*'
					and Minutes <> '*'
					and Hours <> '*'
					and DayOfMonth <> '*'
					and isnumeric(Month) = 1
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/')
				--Hierarchy for yyyy/MM/dd/
				when seconds <> '*'
					and Minutes <> '*'
					and Hours <> '*'
					and isnumeric(DayOfMonth) = 1
					and Month = '*'
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'dd/')
				--Hierarchy for yyyy/MM/dd/HH
				when seconds <> '*'
					and Minutes <> '*'
					and isnumeric(Hours) = 1
					and DayOfMonth = '*'
					and Month = '*'
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'dd/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'HH/')
				--Hierarchy for yyyy/MM/dd/HH/mm
				when seconds <> '*'
					and isnumeric(Minutes) = 1
					and Hours = '*'
					and DayOfMonth = '*'
					and Month = '*'
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'dd/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'HH/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'mm/') 
				--Hierarchy for yyyy/MM/dd/HH/mm/ss
				when isnumeric(seconds) = 1
					and Minutes = '*'
					and Hours = '*'
					and DayOfMonth = '*'
					and Month = '*'
					then format([CTL].[udf_CronToDatetime](@CRONExp), 'yyyy/') + 
						format([CTL].[udf_CronToDatetime](@CRONExp), 'MM/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'dd/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'HH/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'mm/') +
						format([CTL].[udf_CronToDatetime](@CRONExp), 'ss/') 
				end RunFrequency
			from (
				select [1] Seconds , [2] Minutes , [3] Hours , [4] DayOfMonth, [5] Month, [6] DayOfWeek, [7] Year
				from (
						SELECT ItemNumber, Item
						FROM [CTL].[udf_DelimitedSplit8K](@CRONExp, ' ') 
					)a
					PIVOT
				(
					MAX(Item)
					FOR ItemNumber IN
						([1], [2], [3], [4], [5], [6], [7])
				) piv
			)a
		)b
	)
end
GO
PRINT N'Creating Procedure [CTL].[GetStageTableSQL]...';


GO
CREATE Procedure [CTL].[GetStageTableSQL] (@TargetId BigInt)
As
  Declare @Output table (command varchar(max))
  Declare @SQL varchar(max) = ''


  BEGIN
    If (Select Count(*)
          From CTL.ControlTarget ct
            Join CTL.ControlTargetColumns ctc
              On ct.TargetId = ctc.TargetId
         Where ct.TargetId = @TargetId) = 0
      BEGIN
        RAISERROR('Target table definition is not available.',16,1)
      END
    Else
      BEGIN
        Insert into @Output
        Select 'Exec (''DROP TABLE IF EXISTS ' + ct.TargetLocation + '.' + ct.TargetName + char(10) + char(13) + char(10) + char(13) + ''') Select 1'
          From CTL.ControlTarget ct
         Where ct.TargetId = @TargetId

        Select @SQL = 'Exec(''CREATE TABLE ' + ct.TargetLocation + '.' + ct.TargetName + ' ( '
          From CTL.ControlTarget ct
         Where ct.TargetId = @TargetId

        Select @SQL = @SQL + ColumnName + '  ' + DataType + Case When ctc.MaxLength = -1 then '(MAX)' 
                  When ctc.MaxLength = 0 then '' else '(' + Convert(varchar, ctc.MaxLength) + case when ctc.Precision = 0 then ')' else ', ' + convert(varchar, ctc.Precision) + ')' end end + ', '
          From CTL.ControlTargetColumns ctc
         Where ctc.TargetId = @TargetId
         
        Select @SQL = LEFT(@SQL, LEN(@SQL) - 1) + ' )'')' + char(10) + char(13) + char(10) + char(13) + ' Select 1'

        Insert into @Output Values (@SQL)

        Select * From @Output

      END

  END
GO
PRINT N'Creating Procedure [CTL].[GetProjectSchedule]...';


GO
CREATE PROCEDURE [CTL].[GetProjectSchedule]
As

With times as
(
Select p.ProjectName, ps.*, 
	   [CTL].[fn_getWAustDateTime](getdate()) CurrentTime,
       [CTL].[udf_CronToDatetime](ps.CronExpression) ExecutionTime
  From [CTL].[ControlProjects] p
    Join [CTL].[ControlProjectSchedule] ps
      On p.ProjectId = ps.ControlProjectId
 Where p.Enabled = 1
)

Select t.ControlProjectId, t.ProjectName, format(t.ExecutionTime, 'HH:mm:ss')
  From times t
 Where Case When CurrentTime >= ExecutionTime And CurrentTime <= DATEADD(MI, 10, ExecutionTime)
         Then 1
         Else 0
       End = 1
GO
PRINT N'Creating Procedure [CTL].[GetProjects]...';


GO
CREATE PROCEDURE [CTL].[GetProjects] (
	@TriggerName varchar(100)
)
As

--Get List of ProjectID for which Triggers have been configured
SELECT DISTINCT 
	P.ProjectId
	,P.ProjectName
FROM CTL.ControlProjectSchedule S
INNER JOIN CTL.ControlProjects P ON S.ControlProjectId = P.ProjectId
AND P.Enabled = 1
AND S.TriggerName = @TriggerName

/*
SELECT ProjectId as ControlProjectID, ProjectName
FROM CTL.ControlProjects
WHERE Enabled = 1
AND TriggerName = @TriggerName
*/
GO
PRINT N'Creating Procedure [CTL].[GetManifestTrusted]...';


GO

CREATE PROCEDURE CTL.GetManifestTrusted (
	@SourceObject varchar(100)
)
AS
	SELECT
	*
	FROM CTL.ControlManifest
	WHERE SourceObject = @SourceObject
	AND RecordCountLoaded > 0 
	AND ProcessedToTrustedZone IS NULL 
	AND RecordCountDeltaTable IS NOT NULL 
	ORDER BY StartCounter
GO
PRINT N'Creating Procedure [CTL].[GetManifestSQLEDW]...';


GO

CREATE PROCEDURE [CTL].[GetManifestSQLEDW] (
	@SourceObject varchar(100)
)
AS

	--Get the Audit Table for Main Table
	DECLARE @AuditTable VARCHAR(100)
	SELECT @AuditTable = A.SourceName
	FROM CTL.ControlSource S 
	LEFT JOIN CTL.ControlSource A ON S.SoftDeleteSource = A.SourceLocation
	WHERE S.SourceName = @SourceObject

	--If there is no Audit Table defined then use the same table as default
	IF @AuditTable IS NULL OR @AuditTable = ''
		SET @AuditTable = @SourceObject

	SELECT
	ISNULL(MIN(StartCounter),0) AS StartCounter, 
	ISNULL(MAX(EndCounter), 0) AS EndCounter, 
	ISNULL(MAX(DeltaColumn), '''') AS DeltaColumn, 
	ISNULL(COUNT(BatchExecutionLogID), 0) AS Batches 
	FROM CTL.ControlManifest
	WHERE 1 = 1
	AND (SourceObject = @SourceObject OR SourceObject = @AuditTable) --Check the Manifest logs for both the main and Audit table
	AND ProcessedToSQLEDW IS NULL 
	AND ProcessedToTrustedZone IS NOT NULL
GO
PRINT N'Creating Procedure [CTL].[GetManifestRecords]...';


GO
CREATE PROCEDURE [CTL].[GetManifestRecords] (
@BatchID bigint)
AS
SELECT [BatchExecutionLogID]
      ,TaskExecutionLogID
      ,[SourceObject]
      ,[Container]
      ,[StartCounter]
      ,[EndCounter]
      ,RecordCountLoaded
      ,[FolderName]
      ,[FileName]
  FROM [CTL].[ControlManifest]
  WHERE BatchExecutionLogID = @BatchID
GO
PRINT N'Creating Procedure [CTL].[GetManifestAudit]...';


GO

CREATE PROCEDURE [CTL].[GetManifestAudit] (
	@SourceObject varchar(100)
)
AS

	SELECT
	ISNULL(MIN(StartCounter),0) AS StartCounter, 
	ISNULL(MAX(EndCounter), 0) AS EndCounter, 
	ISNULL(MAX(DeltaColumn), '''') AS DeltaColumn, 
	ISNULL(COUNT(BatchExecutionLogID), 0) AS Batches 
	FROM CTL.ControlManifest
	WHERE SourceObject = @SourceObject
	AND RecordCountLoaded > 0 
	AND ProcessedToTrustedZone IS NULL 
	AND RecordCountDeltaTable IS NOT NULL
GO
PRINT N'Creating Procedure [CTL].[GetExecutionTasks]...';


GO





--[CTL].[getExecutionTasks] 1,1

CREATE Procedure [CTL].[GetExecutionTasks] (@StageId BigInt, @ProjectId BigInt)
As

With allTasks as
(
Select 
	styp.ControlType SourceType, 
	src.SourceServer, 
	src.SourceName, 
	src.SourceLocation, 
	src.AdditionalProperty,
	src.Processor, 
	src.IsAuditTable,
	ISNULL(Audit.SourceName, '') AS SoftDeleteSource,
	p.ProjectName,
	p.ProjectId,
	ttyp.ControlType TargetType, 
	targ.TargetName, 
	targ.TargetLocation, 
	targ.TargetServer, 
--	targ.Compressed,
    ct.DataLoadMode, 
	DLT.DeltaExtract,
	DLT.CDCSource,
	DLT.TruncateTarget,
	DLT.UpsertTarget,
	CT.TrackChanges,
	CT.LoadToSqlEDW,
	ct.TaskName, 
	ct.ControlStageId, 
	--cps.CronExpression,  
	ct.TaskId, 
	cs.StageSequence, 
	cs.StageName, 
	src.SourceId, 
	ct.TargetId,
	ct.ObjectGrain, 
	ctc.CommandTypeId, 
	CW.Watermarks,
	FORMAT(TRY_CONVERT(DATETIME, CW.Watermarks), 'yyyy-MM-ddTHH:mm:ss') WatermarksDT,
	ISNULL(CW.SourceColumn, '') AS WatermarkColumn,
	src.BusinessKeyColumn,
	Case 
	    When (ctc.CommandTypeId = 1 OR ctc.CommandTypeId = 6) AND DLT.DeltaExtract = 1
		Then CTL.[udf_GetDeltaSQL](ct.TaskId)
		Else ctc.Command
	End Command,
	CTL.[udf_GetLastLoadedFile](src.SourceName, src.SourceLocation) LastLoadedFile

  From CTL.ControlSource src
    Join CTL.ControlTypes styp On src.SourceTypeId = styp.TypeId
    Join CTL.ControlTasks ct On src.SourceId = ct.SourceId
	Join CTL.ControlTaskCommand ctc On ct.TaskId = ctc.ControlTaskId
	Join CTL.ControlStages cs On ct.ControlStageId = cs.ControlStageId
	Join CTL.ControlTarget targ On ct.TargetId = targ.TargetId
	Join CTL.ControlTypes ttyp On targ.TargetTypeId = ttyp.TypeId
	LEFT JOIN CTL.ControlProjects P ON ct.ProjectId = p.ProjectId
	--join [CTL].[ControlProjectSchedule] cps on ct.ProjectId = cps.ControlProjectId
	LEFT JOIN CTL.ControlWatermark CW ON SRC.SourceId = CW.ControlSourceId
	LEFT JOIN CTL.ControlDataLoadTypes DLT ON CT.DataLoadMode = DLT.DataLoadType
	LEFT JOIN CTL.ControlSource Audit ON ISNULL(src.SoftDeleteSource, '') = Audit.SourceLocation AND Audit.IsAuditTable = 1
	LEFT JOIN CTL.TaskExecutionLog tel On ct.TaskId = tel.ControlTaskId
		   And tel.StartTime = (Select Max(StartTime) From CTL.TaskExecutionLog Where ControlTaskId = ct.TaskId)
 Where ct.TaskEnabled = 1
   And ct.ControlStageId = @StageId
   And ct.ProjectId = @ProjectId
),
lastFullExecutions As
(
Select ct.TaskId, Max(tel.EndTime) LastExecutionDate
  From CTL.ControlSource src
    Join CTL.ControlTasks ct On src.SourceId = ct.SourceId 
	Join CTL.TaskExecutionLog tel On ct.TaskId = tel.ControlTaskId
 Where ct.TaskEnabled = 1
   And ct.ControlStageId = @StageId  
   And ct.ProjectId = @ProjectId
   And tel.ExecutionStatus In ('Success', 'Failure', 'Terminated')
 Group By ct.TaskId
),
noExecutions As
(
Select ct.TaskId
  From CTL.ControlSource src
    Join CTL.ControlTasks ct On src.SourceId = ct.SourceId
	Left Join CTL.TaskExecutionLog tel On ct.TaskId = tel.ControlTaskId
 Where ct.TaskEnabled = 1
   And ct.ControlStageId = @StageId
   And ct.ProjectId = @ProjectId
   And tel.ControlTaskId Is Null
)

Select *
  From allTasks t
 Where (TaskId In (Select TaskId From noExecutions)
   Or t.TaskId In (Select ct.TaskId 
                   From CTL.ControlTasks ct
				     Join lastFullExecutions ex
					   On ct.TaskId = ex.TaskId))
				  --Where (Case 
				  --        When ct.RunFrequencyTypeId = 1 and DATEDIFF(Hour,ex.lastExecutionDate, getdate()) > 24 --Daily
						--    then 1
						--  When ct.RunFrequencyTypeId = 2 and DATEDIFF(Hour, ex.lastExecutionDate, getdate()) > 1 --Hourly
						--    then 1
						--  When ct.RunFrequencyTypeId = 3 and DATEDIFF(day, ex.lastExecutionDate, getdate()) > 7 --Annualy
						--    then 1
						--  Else 0
						--End) = 1))
 Order BY t.StageSequence, t.TaskId
GO
PRINT N'Creating Procedure [CTL].[GetExecutionStages]...';


GO


-- EXEC [CTL].[getExecutionStages] 1

CREATE Proc [CTL].[GetExecutionStages] (
	@ProjectId BigInt,
	@TriggerName VARCHAR(100)
	)
As

SELECT DISTINCT 
	PS.ControlProjectId AS ProjectId, 
	PS.ControlStageId,
	S.StageName,
	S.StageSequence
FROM CTL.ControlProjectSchedule PS
INNER JOIN CTL.ControlStages S ON PS.ControlStageID = S.ControlStageId
AND PS.ControlProjectId = @ProjectID
AND PS.TriggerName = @TriggerName
AND EXISTS (SELECT 1 FROM CTL.ControlTasks T WHERE T.ProjectId = PS.ControlProjectId AND T.ControlStageId = S.ControlStageId)
ORDER BY S.StageSequence
GO
PRINT N'Creating Procedure [CTL].[GetComplianceProcessingStartDate]...';


GO
CREATE PROCEDURE CTL.GetComplianceProcessingStartDate
AS

WITH AllList AS (
SELECT  [SourceObject]
      ,[StartCounter]
	  ,[EndCounter]
	  ,ROW_NUMBER() over (PARTITION BY SourceObject ORDER BY StartCounter desc) RID
  FROM [CTL].[ControlManifest]
  WHERE SourceObject in (
	SELECT SourceName
	FROM CTL.ControlComplianceDependency Compliance
	INNER JOIN CTL.ControlSource Source ON Source.SourceLocation = Compliance.TableName
	)
), LastLoadedTime AS (
	SELECT 
		SourceObject
		,StartCounter
		,EndCounter
	FROM AllList
	WHERE RID IN (1)
)
SELECT
	MIN(StartCounter) AS ProcessingStartTimeStamp, CONVERT(DATE, (MIN(StartCounter))) ProcessingStartDate
	--*
FROM LastLoadedTime
GO
PRINT N'Creating Procedure [CTL].[GetAPIParams]...';


GO
CREATE PROCEDURE [CTL].[GetAPIParams] (@SourceId BigInt)
AS

BEGIN

	DECLARE @MappingInfo VARCHAR(MAX)
	IF EXISTS(SELECT 1 FROM CTL.ControlSource WHERE SourceID = @SourceId AND AdditionalProperty <> '')
	BEGIN

		DECLARE @Prop varchar(max)
		SELECT @Prop = AdditionalProperty FROM CTL.ControlSource WHERE SourceID = @SourceId

		DECLARE @CurrPos int, @NextPos int

		SET @CurrPos = 0
		SET @NextPos = CHARINDEX('|', @Prop, @CurrPos+1)
		DECLARE @Cols varchar(MAX) = SUBSTRING(@Prop, @CurrPos+1, @NextPos - @CurrPos - 1)

		SET @CurrPos = @NextPos
		SET @NextPos = CHARINDEX('|', @Prop, @CurrPos+1)
		DECLARE @CollectionFilter varchar(100) = SUBSTRING(@Prop, @CurrPos+1, @NextPos - @CurrPos - 1)

		/*********Get Mapping Information ***************/
		IF @Cols != ''
		BEGIN
			DECLARE @json_construct varchar(MAX) = '{"type": "TabularTranslator", "mappings": {X}, "collectionReference": "{CollectionFilter}"}';
			DECLARE @json VARCHAR(MAX);
    
			SET @json = (
				SELECT
					c.[value] AS 'source.path', 
					c.[value] AS 'sink.path' 
				FROM (select value from string_split(@cols, ',')) as c
			FOR JSON PATH );
 
			SET @MappingInfo = REPLACE(REPLACE(@json_construct,'{X}', @json),'{CollectionFilter}', @CollectionFilter) 
		END
	END

	SELECT @MappingInfo AS MappingInfo
END

--[CTL].[GetAPIParams] 622
GO
PRINT N'Creating Procedure [CTL].[DeleteProjectConfig]...';


GO
CREATE     PROC [CTL].[DeleteProjectConfig]
@projectId int
AS

Delete From [CTL].[ControlTaskCommand]
where ControlTaskId in (select TaskId from CTL.ControlTasks where ProjectId = @projectId)

DELETE FROM CTL.ControlManifest
WHERE TaskExecutionLogID IN (
	SELECT ExecutionLogID
	FROM CTL.TaskExecutionLog TEL
	LEFT JOIN CTL.ControlTasks CT ON TEL.ControlTaskId = CT.TaskId
	AND ProjectId = @projectId
)

Delete From [CTL].[TaskExecutionLog]
where ControlTaskId in (select TaskId from CTL.ControlTasks where ProjectId = @projectId)

Delete From [CTL].[BatchExecutionLog]
Where ProjectID = @projectId


Drop table if exists #tempSource
Select distinct SourceId 
Into #tempSource
From CTL.ControlSource
where SourceId in (select SourceId from CTL.ControlTasks Where ProjectId = @projectId)

Drop table if exists #tempTarget
Select distinct TargetId 
Into #tempTarget
From CTL.ControlTarget
where TargetId in (select TargetId from CTL.ControlTasks Where ProjectId = @projectId)

Delete From [CTL].[ControlWatermark]
where ControlSourceId in (select SourceId from #tempSource)

Delete From [CTL].[ControlTasks]
where SourceId in (select SourceId from #tempSource)
			
Delete From [CTL].[ControlSource]
where SourceId in (select SourceId from #tempSource)
			
Delete From [CTL].[ControlTarget]
where TargetId in (select TargetId from #tempTarget)

Drop table if exists #tempBatch
Drop table if exists #tempSource
Drop table if exists #tempTarget
GO
PRINT N'Creating Procedure [CTL].[DeleteConfigTask]...';


GO


CREATE PROCEDURE [CTL].[DeleteConfigTask] (
	@ProjectName varchar(255),
	@TaskName varchar(255))
AS

DECLARE @StageID int = 1

DECLARE @ProjectID bigint
DECLARE @TaskID bigint, @SourceID bigint, @TargetID bigint

WHILE @StageID <= 5
BEGIN
	SELECT @ProjectID = ProjectID FROM CTL.ControlProjects WHERE ProjectName = @ProjectName

	SELECT @TaskID = TaskId, @SourceID = SourceId, @TargetID = TargetId
	FROM CTL.ControlTasks T
	WHERE T.ProjectId = @ProjectID
	AND T.TaskName = @TaskName
	AND T.ControlStageId = @StageID

	PRINT @ProjectID
	PRINT @TaskID
	PRINT @SourceID
	PRINT @TargetID


	PRINT 'Deleting from ControlWatermark'
	DELETE FROM CTL.ControlWatermark
	WHERE ControlSourceId = @SourceID

	PRINT 'Deleting from TaskExecutionLog'
	DELETE FROM CTL.TaskExecutionLog
	WHERE ControlTaskId = @TaskID

	PRINT 'Deleting from ControlTaskCommand'
	DELETE FROM CTL.ControlTaskCommand
	WHERE ControlTaskId = @TaskID

	PRINT 'Deleting from ControlWatermark'
	DELETE FROM CTL.ControlWatermark
	WHERE ControlSourceId = @TaskID

	PRINT 'Deleting from ControlTasks'
	DELETE FROM CTL.ControlTasks
	WHERE TaskId = @TaskID

	PRINT 'Deleting from ControlSource'
	DELETE FROM CTL.ControlSource
	WHERE SourceId = @SourceId

	PRINT 'Deleting from ControlTarget'
	DELETE FROM CTL.ControlTarget
	WHERE TargetId = @TargetID


	PRINT 'Deleting from ControlManifest'
	DELETE FROM CTL.ControlManifest
	WHERE SourceObject = @TaskName

	SET @StageID = @StageID + 1

END
GO
PRINT N'Creating Procedure [CTL].[CuratedLogStart]...';


GO

CREATE PROCEDURE [CTL].[CuratedLogStart] (
	@BatchExecutionLogID bigint,
	@TaskExecutionLogID bigint,
	@SubjectArea varchar(255),
	@Project varchar(255),
	@StartPeriod datetime,
	@EndPeriod datetime)
AS

--Reset the previous status to Terminated if they were unfinished
UPDATE CTL.ControlCuratedManifest
SET LoadStatus = 'TERMINATED'
WHERE SubjectArea = @SubjectArea
	AND Project = @Project
	AND LoadStatus = 'STARTED'

--Create new log entry on the Manifest table
INSERT INTO CTL.ControlCuratedManifest (
	BatchExecutionLogID
	,TaskExecutionLogID
	,SubjectArea
	,Project
	,StartPeriod
	,EndPeriod
	,LoadStatus
	,StartTimestamp
	,EndTimeStamp)
VALUES (
	@BatchExecutionLogID
	,@TaskExecutionLogID
	,@SubjectArea
	,@Project
	,@StartPeriod
	,@EndPeriod
	,'STARTED'
	,[CTL].[udf_GetDateLocalTZ]()
	,NULL)
GO
PRINT N'Creating Procedure [CTL].[CuratedLogComplete]...';


GO

CREATE PROCEDURE [CTL].[CuratedLogComplete] (
	@BatchExecutionLogID bigint,
	@TaskExecutionLogID bigint)
AS


UPDATE CTL.ControlCuratedManifest
SET LoadStatus = 'COMPLETE',
EndTimeStamp = [CTL].[udf_GetDateLocalTZ]()
WHERE BatchExecutionLogID = @BatchExecutionLogID
	AND TaskExecutionLogID = @TaskExecutionLogID
	AND LoadStatus = 'STARTED'
GO
PRINT N'Creating Procedure [CTL].[CuratedGetProcessingPeriod]...';


GO
CREATE PROCEDURE [CTL].[CuratedGetProcessingPeriod] (
	@SubjectArea varchar(255),
	@Project varchar(255)
	)
AS

--DECLARE @SubjectArea varchar(255) = 'NAT';
--DECLARE @Project varchar(255) = 'ComplianceCurated';

DECLARE @StartDate DATETIME;
DECLARE @EndDate DATETIME;

IF EXISTS(SELECT 1 FROM CTL.ControlCuratedConfig Config WHERE Config.SubjectArea =  @SubjectArea AND Config.Project =  @Project)
BEGIN
	--Check If there are configuration then get the dates from data load information
	WITH AllList AS (
		--Get all the data load entries from ControlManifest for the passed parameter for Curated Entity and Rank them
		SELECT  
			[SourceObject]
			,[StartCounter]
			,[EndCounter]
			,ROW_NUMBER() over (PARTITION BY SourceObject ORDER BY StartCounter desc) RowRank
		FROM [CTL].[ControlManifest]
		WHERE SourceObject in (
			--Check for matching records in the Configuration Table ControlCuratedConfig
			SELECT SourceName
			FROM CTL.ControlCuratedConfig Config
			INNER JOIN CTL.ControlSource Source ON Source.SourceLocation = Config.DependentTableName
			WHERE Config.SubjectArea =  @SubjectArea
			AND Config.Project =  @Project
			AND Config.Valid = 1
			AND ProcessedToTrustedZone = 1
		)
	), LastLoadedTime AS (
		--Take only the latest load for each table
		SELECT 
			SourceObject
			,StartCounter
			,EndCounter
		FROM AllList
		WHERE RowRank IN (1)
	)
	SELECT
		--Get the minimum of each Start Date as Processing Start Time. Default to midnight time
		@StartDate = CONVERT(DATETIME, CONVERT(DATE, (MIN(StartCounter))))
		--Get current datetime at midnight as the Processing End Time
		,@EndDate = CONVERT(DATETIME, CAST(SYSDATETIMEOFFSET() AT TIME ZONE 'AUS Eastern Standard Time' AS date))
		--*
	FROM LastLoadedTime
END
ELSE
BEGIN
	--If there are no configuration then set the default dates
	SET @StartDate = '2000-01-01 00:00:00'
	SET @EndDate = '9999-12-31 00:00:00'
END


SELECT @StartDate AS ProcessingStartDate, @EndDate AS ProcessingEndDate
GO
PRINT N'Creating Procedure [CTL].[CreateTaskLog]...';


GO
CREATE Procedure [CTL].[CreateTaskLog] (@BatchLogId BigInt, @TaskId BigInt)
As
BEGIN
	If (Select Count(*) From CTL.BatchExecutionLog Where BatchExecutionLogId = @BatchLogId And BatchExecutionStatus = 'In Progress') = 0
	  BEGIN
		RAISERROR('Batch execution log could not be located',16,1)
	  END
	Else
	  BEGIN
	    If (Select Count(*) From CTL.TaskExecutionLog Where ControlTaskId = @TaskId And ExecutionStatus = 'In Progress') > 0
		  BEGIN
			RAISERROR('Task is already in progress',16,1)
		  END
		Else
		  BEGIN
			Insert Into CTL.TaskExecutionLog (BatchExecutionId, ControlTaskId, StartTime, ExecutionStatus) 
				Values (@BatchLogId, @TaskId, [CTL].[udf_GetDateLocalTZ](), 'In Progress')
			Select @@IDENTITY TaskLogId
		  END
	  END
END
GO
PRINT N'Creating Procedure [CTL].[CreateTask]...';


GO




CREATE Procedure [CTL].[CreateTask] 
	@SourceName Varchar(255) = '',
    @SourceLocation Varchar(255) = '',
	@SourceTypeId BigInt = 2,  
	@SourceServer varchar(255) = '',
	@Processor varchar(255) = '',
	@TargetName Varchar(255) = '',
	@TargetLocation Varchar(255) = '',
	@TargetTypeId BigInt = 4,
	@TargetServer varchar(255)= '',
	@StageId BigInt = 2,
	@ProjectId BigInt = 1,
	@CommandType int = 1,
	@Command varchar(max)= '',
	@DataLoadMode varchar(100) = '',
	@Grain varchar(30) = '',
	@BusinessKeyColumn varchar(100) = '',
	@WatermarkColumn varchar(100) = '',
	@TrackChangeFlag bit = 0,
	@AdditionalProperty	varchar(max) = '', 
	@LoadToSqlEDW BIT = 0,
	@IsAuditTable BIT = 0,
	@SoftDeleteSource varchar(100) = ''

As
BEGIN
	Declare	@SourceId BigInt,
	        @TargetId BigInt,
			@TaskId BigInt

	Begin Try
	Begin Transaction

		DECLARE @UseAuditTable INT
		SET @UseAuditTable = 0 --The default value to UseAuditTable is False for now. If Audit Table is to be used, then set the value to 1 manually

		--If the table is a Audit table, update the values for Audit Table
		IF @IsAuditTable = 1
		BEGIN
			PRINT 'Processing records for Audit Table'
			SET @LoadToSqlEDW = 0 --Do not load Audit table to SQLEDW
			SET @DataLoadMode  = 'APPEND' --No Merge required for Audit table
			SET @TrackChangeFlag = 0 --No track changes required

			IF @StageId = 1
			BEGIN
				SET @Command = 'SELECT ' + @BusinessKeyColumn + ', ' + @WatermarkColumn + ' FROM ' + @SourceLocation --Update SQL to fetch only needed columns
			END

		END

		PRINT 'Adding record to ControlSource'
		Insert Into CTL.ControlSource (SourceName, SourceTypeId, SourceLocation, LoadSource, SourceServer, Processor, BusinessKeyColumn, AdditionalProperty, IsAuditTable, SoftDeleteSource, UseAuditTable) 
		Values(@SourceName, @SourceTypeId, @SourceLocation, 1, @SourceServer, @Processor, @BusinessKeyColumn, @AdditionalProperty, @IsAuditTable, @SoftDeleteSource, @UseAuditTable)
		Select @SourceId = @@IDENTITY

		PRINT 'Adding record to ControlTarget'
		Insert Into CTL.ControlTarget (TargetName, TargetTypeId, TargetLocation, TargetEnabled, TargetServer, Compressed) 
		Values (@SourceName, @TargetTypeId, @TargetLocation, 1, @TargetServer, 1)
		Select @TargetId = @@IDENTITY

		PRINT 'Adding record to ControlTasks'
		Insert Into CTL.ControlTasks (TaskName, SourceId, TargetId, TruncateTarget, TaskEnabled, LoadLatestOnly, 
			ExecuteSourceSQLasStoredProc, ControlStageId, ProjectId, ObjectGrain, DataLoadMode, TrackChanges, LoadToSqlEDW)
		Values (@SourceName, @SourceId, @TargetId, 0, 1, 0, 1, @StageId, @ProjectId, @Grain, @DataLoadMode, @TrackChangeFlag, @LoadToSqlEDW)
		Select @TaskId = @@IDENTITY
		
		PRINT 'Adding record to ControlTaskCommand'
		Insert Into CTL.[ControlTaskCommand] (ControlTaskId, CommandTypeId, Command)
		Values (@TaskId, @CommandType, @Command)

		--Updated by Rahul to add the default entry for Watermark for CDC Sources
		IF @DataLoadMode = 'CDC' AND @StageId = 1
		BEGIN
			PRINT 'Inserting initial watermark for CDC' 
			DECLARE @StartLSN varchar(20)
			SELECT @StartLSN = upper(sys.fn_varbintohexstr(sys.fn_cdc_map_time_to_lsn('START-LSN', '2000-01-01 12:00:00.000')))

			INSERT INTO CTL.ControlWatermark (ControlSourceId, SourceColumn, SourceSQL, Watermarks, SourceName)
			VALUES (@TaskId, '__$start_lsn', '', @StartLSN, @SourceName)
		END

		IF @DataLoadMode IN ('INCREMENTAL', 'APPEND') AND @StageId = 1
		BEGIN
			PRINT 'Inserting initial watermark column'

			INSERT INTO CTL.ControlWatermark (ControlSourceId, SourceColumn, SourceSQL, Watermarks, SourceName)
			VALUES (@SourceId, @WatermarkColumn, @WatermarkColumn, '2000-01-01 00:00:00', @SourceName)
		END

		IF NOT EXISTS(SELECT 1 FROM CTL.ControlProjectSchedule WHERE ControlProjectId = @ProjectId AND ControlStageID = @StageId)
		BEGIN
			DECLARE @ProjectName varchar(100)
			SELECT @ProjectName = ProjectName FROM CTL.ControlProjects WHERE ProjectId = @ProjectId
			--If the Project Schedule does not exist, add a default schedule entry
			INSERT INTO CTL.ControlProjectSchedule (ControlProjectId, ControlStageID, TriggerName) VALUES (@ProjectId, @StageId, @ProjectName)
		END


	Commit
	End Try
	Begin Catch

		Rollback
		Declare @err_num  int = @@ERROR
		Declare @err_desc varchar(500) = ERROR_MESSAGE()
		raiserror(@err_desc,@err_num,1)

	End Catch

END
GO
PRINT N'Creating Procedure [CTL].[CreateSource]...';


GO


CREATE PROC [CTL].[CreateSource] 
        @ProjectName		 varchar(100),
		@StartStageName		 varchar(100),
		@EndStageName		 varchar(100),
		@SourceName			 varchar(100),
		@SourceObjectName	 varchar(500),
		@SourceType			 varchar(100),
		@DataLoadMode		 varchar(100),
		@SourceSecretName	 varchar(100),
		@DLRawSecret		 varchar(100),
		@DLStagedSecret		 varchar(100),
		@DBProcessor		 varchar(100),
		@StageDBSecret		 varchar(100),
		@DLRawSubFolder		 varchar(100),
		@DLRawType			 varchar(100),
		@DLStagedMainFolder	 varchar(100),
		@DLStagedSubFolder	 varchar(100),
		@DLStagedType		 varchar(100),
		@DLObjectGrain		 varchar(100),
		@SourceCommand		 varchar(5000),
		@DLRawtoStageCommand varchar(5000),
		@DLStagetoDBCommand  varchar(5000),
		@TargetObjectType	 varchar(100),
		@TargetOverride		 varchar(150),
		@BusinessKeyColumn	 varchar(150),
		@WatermarkColumn	 varchar(150),
		@TrackChanges		 varchar(100),
		@AdditionalProperty	 varchar(max),
		@IsAuditTable		 varchar(100) = '', --Add column to track if the table is a Audit Table
		@SoftDeleteSource	 varchar(100) = '' --Name of the source to be used for Soft Delete
as 

declare @TargetName varchar(1000), @TargetLocation varchar(1000)
SET @TargetName = @SourceObjectName
SET @TargetLocation = @DLRawSubFolder

declare @project int
declare @startStage int, @endStage int
declare @sourceTypeId int, @rawTypeId int, @stageTypeId int, @databricksTypeId int
declare @taskName varchar(650)

declare @error varchar(1000)
declare @counter int
declare @currentStage varchar(50)

--Default option is to load all tables to SQLEDW. If any table does not need to be loaded, then manually run the UPDATE command
DECLARE @LoadToSqlEDW bit = 1

--Update Flags based on value
declare @TrackChangeFlag bit
IF UPPER(@TrackChanges) IN ('YES', 'Y') 
	SET @TrackChangeFlag = 1
ELSE
	SET @TrackChangeFlag = 0

DECLARE @IsAuditTableFlag bit
IF UPPER(@IsAuditTable) IN ('YES', 'Y') 
	SET @IsAuditTableFlag = 1
ELSE
	SET @IsAuditTableFlag = 0

--If Data Load Mode is TRUNCATE-LOAD then TrackChange is false
IF @DataLoadMode = 'TRUNCATE-LOAD'
	SET @TrackChangeFlag = 0

IF @DataLoadMode = 'INCREMENTAL' AND @WatermarkColumn = ''
BEGIN
	RAISERROR('Please specify a WatermarkColumn when the data load mode is INCREMENTAL', 16, 1)
	RETURN
END

IF @DataLoadMode != 'TRUNCATE-LOAD' AND @BusinessKeyColumn = '' AND @StartStageName = 'Source to Raw'
BEGIN
	RAISERROR('Please specify a BusinessKeyColumn column when the data load mode is not TRUNCATE-LOAD', 16, 1) 
	RETURN
END

IF @TrackChangeFlag = 1 AND @BusinessKeyColumn = ''
BEGIN
	RAISERROR('Please specify a BusinessKeyColumn column when TrackChanges is Yes', 16, 1) 
	RETURN
END

--Get project id
set @project = (select ProjectId from [CTL].[ControlProjects] where ProjectName = @ProjectName)

set @error = 'Invalid project name: ' + @ProjectName
if @project is null raiserror(@error,16,1)

--Get start stage id
set @startStage = (select ControlStageId from [CTL].[ControlStages] where StageName = @StartStageName)

set @error = 'Invalid starting stage: ' + @StartStageName
if @startStage is null raiserror(@error,16,1)

--Get end stage id
set @endStage = (select ControlStageId from [CTL].[ControlStages] where StageName = @EndStageName)

set @error = 'Invalid starting stage: ' + @EndStageName
if @endStage is null raiserror(@error,16,1)

--Get source type id
set @sourceTypeId = (select TypeId from [CTL].[ControlTypes] where ControlType = @SourceType)

set @error = 'Invalid source type: ' + @SourceType
if @sourceTypeId is null raiserror(@error,16,1)

--Get raw type id
set @rawTypeId = (select TypeId from [CTL].[ControlTypes] where ControlType = @DLRawType)

set @error = 'Invalid raw zone type: ' + @DLRawType
if @rawTypeId is null raiserror(@error,16,1)

--Get stage type id
set @stageTypeId = (select TypeId from [CTL].[ControlTypes] where ControlType = @DLStagedType)

set @error = 'Invalid stage zone type: ' + @DLStagedType
if @stageTypeId is null raiserror(@error,16,1)


DECLARE @StageFolder varchar(100)
SET @StageFolder =  @DLStagedMainFolder + '/' + @DLStagedSubFolder

--set @deltaFlag = case when @Delta = 'Yes' then 1 else 0 end
set @databricksTypeId = (select typeid from [CTL].[ControlTypes] where ControlType = 'Databricks')

SET @SoftDeleteSource = TRIM(@SoftDeleteSource)
SET @AdditionalProperty = TRIM(@AdditionalProperty)

set @counter = @startStage
While @counter <= @endStage
begin
	
	PRINT 'Starting Stage : ' + CONVERT(VARCHAR, @counter)

	set @currentStage = (select StageName from [CTL].[ControlStages] where ControlStageId = @counter)
	set @taskName = replace(replace(trim(@SourceName + '_' + @SourceObjectName),'[',''),']','')
	set @targetName = replace(replace(trim(@SourceObjectName),'[',''),']','')

	PRINT @currentStage + ' - ' + @taskName + ' - ' + @targetName

	if @currentStage = 'Source to Raw'
	BEGIN
		EXEC [CTL].[CreateTask] 
			@SourceName
			,@SourceObjectName
			,@sourceTypeId
			,@SourceSecretName
			,@DBProcessor
			,@TargetName
			,@TargetLocation
			,@rawTypeId
			,@DLRawSecret
			,@counter
			,@project
			,@sourceTypeId
			,@SourceCommand
			,@DataLoadMode
			,@DLObjectGrain
			,@BusinessKeyColumn
			,@WatermarkColumn
			,@TrackChangeFlag
			,@AdditionalProperty
			,@LoadToSqlEDW
			,@IsAuditTableFlag
			,@SoftDeleteSource

	END

    if @currentStage = 'Raw to Trusted'
	BEGIN
		EXEC [CTL].[CreateTask] 
			@SourceName
			,@TargetLocation
			,@rawTypeId
			,@DLRawSecret
			,@DBProcessor
			,@DLRawSubFolder
			,@StageFolder
			,@StageTypeId
			,@DLStagedSecret
			,@counter
			,@project
			,@databricksTypeId
			,@DLRawtoStageCommand
			,@DataLoadMode
			,@DLObjectGrain
			,@BusinessKeyColumn
			,@WatermarkColumn
			,@TrackChangeFlag
			,@AdditionalProperty
			,@LoadToSqlEDW
			,@IsAuditTableFlag
			,@SoftDeleteSource

	END
	

	if @currentStage = 'Trusted to Curated'
	BEGIN

		EXEC [CTL].[CreateTask] 
			@SourceName
			,@DLStagedMainFolder
			,@stageTypeId
			,@DLStagedSecret
			,@DBProcessor
			,@DLRawSubFolder 
			,@targetName
			,1
			,@StageDBSecret
			,@counter
			,@project
			,@databricksTypeId
			,@DLStagetoDBCommand
			,0
			,@DLObjectGrain
			,@BusinessKeyColumn
			,@WatermarkColumn
			,@TrackChangeFlag
			,@AdditionalProperty
			,@LoadToSqlEDW
			,@IsAuditTableFlag
			,@SoftDeleteSource
	END	

	if @currentStage IN ('Cubes', 'DW Export')
	BEGIN

		SET @TargetLocation = REPLACE(@SourceObjectName, '.', '_')

		EXEC [CTL].[CreateTask] 
			@SourceName
			,@SourceObjectName
			,@SourceTypeId
			,'' --SourceSecretName
			,@DBProcessor
			,@TargetName
			,@TargetLocation
			,@SourceTypeId
			,@SourceSecretName
			,@counter
			,@project
			,@sourceTypeId
			,@SourceCommand
			,@DataLoadMode
			,@DLObjectGrain
			,@BusinessKeyColumn
			,@WatermarkColumn
			,@TrackChangeFlag
			,@AdditionalProperty
			,@LoadToSqlEDW
			,@IsAuditTableFlag
			,@SoftDeleteSource

	END
	set @counter += 1
end
GO
PRINT N'Creating Procedure [CTL].[CreateManifestRecord]...';


GO

CREATE PROCEDURE [CTL].[CreateManifestRecord] (
	@BatchExecutionLogID bigint,
	@TaskExecutionLogID bigint,
	@SourceObject varchar(1000),
	@Container varchar(1000),
	@DeltaColumn varchar(100),
	@StartCounter varchar(500),
	@EndCounter varchar(500),
	@Records bigint,
	@RecordsDeltaTable bigint = 0,
	@FolderName varchar(1000),
	@FileName varchar(1000),
	@PipelineRunID varchar(50) = ''
)
AS 

SET @DeltaColumn = ISNULL(@DeltaColumn, '')

DECLARE @Start varchar(500)
IF ISDATE(@StartCounter) = 1
	SET @Start = FORMAT(TRY_CONVERT(DATETIME, @StartCounter), 'yyyy-MM-ddTHH:mm:ss')
ELSE
	SET @Start = @StartCounter

DECLARE @End varchar(500)
IF ISDATE(@EndCounter) = 1
	SET @End = FORMAT(TRY_CONVERT(DATETIME, @EndCounter), 'yyyy-MM-ddTHH:mm:ss')
ELSE
	SET @End = @EndCounter


INSERT INTO CTL.ControlManifest(
	[BatchExecutionLogID]
	,[TaskExecutionLogID]
	,[SourceObject]
	,[Container]
	,[DeltaColumn]
	,[StartCounter]
	,[EndCounter]
	,[RecordCountLoaded]
	,[RecordCountDeltaTable]
	,[FolderName]
	,[FileName]
	,[RawZonePipelineRunID]
	)
VALUES (
	@BatchExecutionLogID
	,@TaskExecutionLogID
	,@SourceObject
	,@Container
	,@DeltaColumn
	,@Start
	,@End
	,@Records
	,NULL
	,@FolderName
	,@FileName
	,@PipelineRunID
	)
GO
PRINT N'Creating Procedure [CTL].[CreateBatchLog]...';


GO
CREATE Procedure [CTL].[CreateBatchLog] (@ProjectID bigint)
As
BEGIN

	If (Select Count(*) From CTL.BatchExecutionLog Where BatchExecutionStatus = 'In Progress' AND ProjectID = @ProjectID) > 0 
		BEGIN
			RAISERROR('Execution batch already in progress', 16, 1) 
		END
	Else
	  BEGIN
		Insert Into CTL.BatchExecutionLog (StartDate, BatchExecutionStatus, ProjectID) Values ([CTL].[udf_GetDateLocalTZ](), 'In Progress', @ProjectID)
		Select @@IDENTITY BatchLogId
	  END

END
GO
PRINT N'Creating Procedure [CTL].[ClearDB]...';


GO
CREATE   PROC [CTL].[ClearDB]
AS

Delete From [CTL].[ControlTaskCommand]

Delete From [CTL].[TaskExecutionLog]

Delete From [CTL].[BatchExecutionLog]

Delete From [CTL].[ControlWatermark]

Delete From [CTL].[ControlTasks]
			
Delete From [CTL].[ControlSource]
			
Delete From [CTL].[ControlTarget]

DELETE FROM CTL.ControlManifest

DBCC CHECKIDENT ('CTL.ControlTarget',Reseed,0)
DBCC CHECKIDENT ('CTL.ControlSource',Reseed,0)
DBCC CHECKIDENT ('CTL.ControlTasks',Reseed,0)
DBCC CHECKIDENT ('CTL.BatchExecutionLog',Reseed,0)
DBCC CHECKIDENT ('CTL.TaskExecutionLog',Reseed,0)
DBCC CHECKIDENT ('CTL.ControlTaskCommand',Reseed,0)
DBCC CHECKIDENT ('CTL.ControlWatermark',Reseed,0)
GO
PRINT N'Creating Procedure [CTL].[UpdateWatermarks]...';


GO
CREATE Procedure [CTL].[UpdateWatermarks] @SourceId BigInt, @Watermark Varchar(1000)
As

BEGIN


	DECLARE @WatermarkUpdated varchar(500)
	IF ISDATE(@WatermarkUpdated) = 1
		SET @WatermarkUpdated = FORMAT(TRY_CONVERT(DATETIME, @Watermark), 'yyyy-MM-ddTHH:mm:ss')
	ELSE
		SET @WatermarkUpdated = @Watermark

	Update CTL.ControlWatermark
	   Set Watermarks = @WatermarkUpdated
	 Where ControlSourceId = @SourceId
END
GO
PRINT N'Creating Procedure [CTL].[UpdateTaskLog]...';


GO
CREATE Procedure [CTL].[UpdateTaskLog] (@BatchLogId BigInt, @TaskId BigInt, @ExecutionLogId BigInt, @Status Varchar(50), @ErrorMessage varchar(2000), @Output Varchar(2000))
As
BEGIN
	If (Select Count(*) From CTL.BatchExecutionLog Where BatchExecutionLogId = @BatchLogId And BatchExecutionStatus = 'In Progress') = 0
	  BEGIN
		RAISERROR('Batch execution log could not be located',16,1)
	  END
	Else
	  BEGIN
	    If (Select Count(*) From CTL.TaskExecutionLog Where ControlTaskId = @TaskId And ExecutionStatus = 'In Progress') = 0
		  BEGIN
			RAISERROR('Task execution log could not be located',16,1)
		  END
		Else
		  BEGIN
			Update CTL.TaskExecutionLog
			   Set EndTime = [CTL].[udf_GetDateLocalTZ](),
			       ExecutionStatus = @Status,
				   ErrorMessage = @ErrorMessage,
				   TaskOutput = @Output
			 Where ExecutionLogId = @ExecutionLogId
		  END
	  END
END
GO
PRINT N'Creating Procedure [CTL].[UpdateManifestSQLEDW]...';


GO
CREATE PROCEDURE [CTL].[UpdateManifestSQLEDW] (
	@BatchExecutionLogID bigint,
	@SourceObject varchar(255),
	@ProcessedToSQLEDW char(1),
	@PipelineRunID varchar(50)
	)
AS

BEGIN

	--Get the Audit Table for Main Table
	DECLARE @AuditTable VARCHAR(100)
	SELECT @AuditTable = A.SourceName
	FROM CTL.ControlSource S 
	LEFT JOIN CTL.ControlSource A ON S.SoftDeleteSource = A.SourceLocation
	WHERE S.SourceName = @SourceObject

	--If there is no Audit Table defined then use the same table as default
	IF @AuditTable IS NULL OR @AuditTable = ''
		SET @AuditTable = @SourceObject

	IF @ProcessedToSQLEDW = '1'
		UPDATE CTL.ControlManifest SET 
		[ProcessedToSQLEDW] = 1
		,SQLEDWPipelineRunID = @PipelineRunID
		WHERE 1 = 1
		AND (SourceObject = @SourceObject OR SourceObject = @AuditTable) --Check the Manifest logs for both the main and Audit table
		AND [ProcessedToSQLEDW] IS NULL
		AND BatchExecutionLogID <= @BatchExecutionLogID

END
GO
PRINT N'Creating Procedure [CTL].[UpdateManifestDLTrusted]...';


GO
CREATE PROCEDURE [CTL].[UpdateManifestDLTrusted] (
	@SourceObject varchar(255),
	@BatchExecutionLogID bigint,
	@StartCounter varchar(255),
	@PipelineRunID varchar(50))
AS

BEGIN
	UPDATE CTL.ControlManifest SET 
	[ProcessedToTrustedZone] = 1
	,TrustedZonePipelineRunID = @PipelineRunID
	WHERE [ProcessedToTrustedZone] IS NULL
	AND BatchExecutionLogID = @BatchExecutionLogID
	AND SourceObject = @SourceObject
	AND StartCounter = @StartCounter
END
GO
PRINT N'Creating Procedure [CTL].[UpdateManifestDeltaRecords]...';


GO
CREATE PROCEDURE [CTL].[UpdateManifestDeltaRecords] (
	@BatchExecutionLogID bigint,
	@TaskExecutionLogID bigint,
	@RecordsDeltaTable bigint)
AS

BEGIN
	UPDATE CTL.ControlManifest
	SET RecordCountDeltaTable = @RecordsDeltaTable
	WHERE BatchExecutionLogID = @BatchExecutionLogID
	AND TaskExecutionLogID = @TaskExecutionLogID
END
GO
PRINT N'Creating Procedure [CTL].[UpdateManifestAudit]...';


GO
CREATE PROCEDURE [CTL].[UpdateManifestAudit] (
	@BatchExecutionLogID bigint,
	@SourceObject varchar(255),
	@ProcessedToTrusted char(1),
	@PipelineRunID varchar(50))
AS

BEGIN
	IF @ProcessedToTrusted = '1'
		UPDATE CTL.ControlManifest SET 
		[ProcessedToTrustedZone] = 1
		,TrustedZonePipelineRunID = @PipelineRunID
		WHERE [ProcessedToTrustedZone] IS NULL
		AND BatchExecutionLogID <= @BatchExecutionLogID
		AND SourceObject = @SourceObject
END
GO
PRINT N'Creating Procedure [CTL].[UpdateCustomDataLoad]...';


GO
create procedure CTL.UpdateCustomDataLoad (
@TableName varchar(255),
@StartDate date)
AS

UPDATE CTL.CustomDataLoad SET ExtractionComplete = 1
WHERE TableName = @TableName
AND StartDate = @StartDate
GO
PRINT N'Creating Procedure [CTL].[UpdateBatchLog]...';


GO
CREATE Procedure [CTL].[UpdateBatchLog] (@BatchLogId BigInt, @Status Varchar(50), @ErrorMessage Varchar(2000))
As
BEGIN

	If (Select Count(*) From CTL.BatchExecutionLog Where BatchExecutionLogId = @BatchLogId) = 0 
		BEGIN
			RAISERROR('Execution batch could not be located', 16, 1) 
		END
	Else
	  BEGIN
		Update CTL.BatchExecutionLog
		   Set EndDate = [CTL].[udf_GetDateLocalTZ](),
		       BatchExecutionStatus = @Status,
			   ErrorMessage = @ErrorMessage
		 Where BatchExecutionLogId = @BatchLogId
	  END

END
GO
PRINT N'Creating Procedure [CTL].[sp_getFullName]...';


GO
CREATE proc [CTL].[sp_getFullName] (@fileName varchar(255), @Grain varchar(30))
as
begin
	select @fileName + '/' + [CTL].[udf_getFileDateHierarchy](@Grain) + '/' + @fileName + '.csv.gz' FileName
end
GO
PRINT N'Creating Procedure [CTL].[ResetLogs]...';


GO

CREATE PROCEDURE [CTL].[ResetLogs] (@ProjectID INT)
AS

UPDATE ctl.TaskExecutionLog 
SET ExecutionStatus = 'Terminated'
WHERE ExecutionStatus = 'In Progress' AND BatchExecutionId IN 
	(select BatchExecutionLogID from ctl.BatchExecutionLog where ProjectID = @ProjectID)

UPDATE CTL.BatchExecutionLog 
SET BatchExecutionStatus = 'Terminated'
WHERE BatchExecutionStatus = 'In Progress' AND ProjectID = @ProjectID

/*
delete from ctl.TaskExecutionLog where BatchExecutionId IN (select BatchExecutionLogID from ctl.BatchExecutionLog where BatchExecutionStatus = 'In Progress')
delete from ctl.BatchExecutionLog where BatchExecutionStatus = 'In Progress'
delete from ctl.TaskExecutionLog where ExecutionStatus = 'In Progress'

*/
GO
PRINT N'Creating Procedure [CTL].[RecordDataValidation]...';


GO

CREATE PROCEDURE [CTL].[RecordDataValidation] (
	@ProjectRunID varchar(50),
	@ObjectName varchar(255),
	@ValidationType varchar(10),
	@HighWatermark varchar(100),
	@RecordCount bigint,
	@TotalValue bigint,
	@MinValue bigint,
	@MaxValue bigint)
AS

IF UPPER(@ValidationType) = 'SOURCE'
BEGIN

	INSERT INTO CTL.ControlDataLoadValidation (
		ProjectRunID
		,ObjectName
		,SourceHighWatermark
		,SourceRecordCount
		,SourceTotalValue
		,SourceMinValue
		,SourceMaxValue)
	VALUES (
		@ProjectRunID
		,@ObjectName
		,@HighWatermark
		,@RecordCount
		,@TotalValue
		,@MinValue
		,@MaxValue)

END
ELSE
BEGIN
	UPDATE CTL.ControlDataLoadValidation
	SET TargetHighWatermark = @HighWatermark
	,TargetRecordCount = @RecordCount
	,TargetTotalValue = @TotalValue
	,TargetMinValue = @MinValue 
	,TargetMaxValue = @MaxValue

	WHERE ProjectRunID = @ProjectRunID
	AND ObjectName = @ObjectName

END
GO
PRINT N'Creating Procedure [CTL].[GetWatemarkSQL]...';


GO
CREATE Procedure [CTL].[GetWatemarkSQL] @SourceId BigInt
As

BEGIN
Declare @SQL Varchar(2000) = 'SELECT ',
		@TableName Varchar(255) = ' FROM '


DECLARE @DataLoadMode varchar(100)
DECLARE @SourceType varchar(100)
SELECT 
	@DataLoadMode = CT.DataLoadMode 
	,@SourceType = T.ControlType
FROM CTL.ControlTasks CT 
LEFT JOIN CTL.ControlSource CS ON CT.SourceId = CS.SourceId
LEFT JOIN CTL.ControlTypes T ON CS.SourceTypeId = T.TypeId
WHERE CS.SourceId = @SourceId

IF @DataLoadMode = 'CDC'
	BEGIN
		SELECT @SQL = 'SELECT ''UPPER([__$start_lsn])'' AS SourceColumn, upper(sys.fn_varbintohexstr(sys.fn_cdc_get_max_lsn())) AS ReturnValue, sys.fn_cdc_map_lsn_to_time(sys.fn_cdc_get_max_lsn()) AS ReturnTime'
	END
ELSE
	BEGIN
		Select @TableName = @TableName + (Select SourceLocation From CTL.ControlSource Where SourceId = @SourceId)
	
		Declare @Columns Table
		(
		  ColumnName Varchar(255),
		  SourceSQL Varchar(2000)
		)

		Insert Into @Columns
			Select m.SourceColumn, m.SourceSQL
				From CTL.ControlWatermark m
				Where ControlSourceId = @SourceId

		While (Select Count(*) From @Columns) > 0
		  BEGIN

			--Check if the Watermark column contains any comma, meaning there may be more than one column in it
			--If so, use the COALESCE, NVL style functions to get values
			DECLARE @COL varchar(100)
			SET @COL = (Select Top 1 ColumnName From @Columns)
			SET @COL = [CTL].[udf_GetMultiColFilterClause](@COL, @SourceType)

			--Updated by Rahul Agrawal on 28-Jan-2020. Updated the condition to > from >=. The >= operator loads the last watermark data over and over.
			IF @SourceType = 'Oracle'
				Select @SQL = @SQL + ' ''' + @COL + ''' As SourceColumn,  TO_CHAR(MAX(' + @COL + '), ''YYYY-MM-DD HH24:MI:SS'') As ReturnValue, '
			ELSE
				--Select @SQL = @SQL + ' ''' + @COL + ''' As SourceColumn,  FORMAT(MAX(' + @COL + '), ''yyyy-MM-dd hh:mm:ss'') As ReturnValue, '
				--Select @SQL = @SQL + ' ''' + @COL + ''' As SourceColumn,  MAX(' + @COL + ') As ReturnValue, '
				Select @SQL = @SQL + ' ''' + @COL + ''' As SourceColumn,  FORMAT(MAX(' + @COL + '), ''yyyy-MM-dd HH:mm:ss'') As ReturnValue, '

--			Select @SQL = @SQL + ' ''' + (Select Top 1 ColumnName From @Columns) + ''' As SourceColumn,  MAX(' + @UpdateCol + ') As ReturnValue, '
--			Delete Top(1) From @Columns

			Delete Top(1) From @Columns
		  END

		Select @SQL = LEFT(@SQL, Len(@SQL) - 1)

		Select @SQL = @SQL + @TableName

	END


Select @SQL SQLStatement

END
GO
PRINT N'Creating Procedure [CTL].[GetTableDetails]...';


GO
CREATE Procedure [CTL].[GetTableDetails] (
	@SourceId BigInt
	,@ValidationType varchar(10) = 'SOURCE'
)
As

BEGIN

--DECLARE @SourceId BIGINT = 1008
--DECLARE @ValidationType varchar(10) = 'TARGET'

DECLARE @SQL Varchar(2000) = 'SELECT ',
		@TableName Varchar(255) = ' FROM '


DECLARE @DataLoadMode varchar(100)
DECLARE @SourceType varchar(100)
DECLARE @SourceTable varchar(100)
DECLARE @SourceColumn varchar(100)
DECLARE @ValidationColumn varchar(100)
DECLARE @SourceName varchar(100)
DECLARE @NULLFunction varchar(100), @DATEFunction varchar(100), @DATEFormat varchar(100)


SELECT 
	@DataLoadMode = CT.DataLoadMode 
	,@SourceType = T.ControlType
	,@SourceTable = CS.SourceLocation
	,@SourceColumn = W.SourceColumn
	,@ValidationColumn = CS.ValidationColumn
	,@SourceName = CS.SourceName
FROM CTL.ControlTasks CT 
LEFT JOIN CTL.ControlSource CS ON CT.SourceId = CS.SourceId
LEFT JOIN CTL.ControlTypes T ON CS.SourceTypeId = T.TypeId
LEFT JOIN CTL.ControlWatermark W ON W.ControlSourceId = CS.SourceId
WHERE CS.SourceId = @SourceId

SET @NULLFunction = 'ISNULL'
SET @DATEFunction = 'FORMAT'
SET @DATEFormat = '''yyyy-MM-dd HH:mm:ss'''


IF @ValidationType = 'SOURCE'
BEGIN
	IF @SourceType = 'Oracle'
	BEGIN
		SET @NULLFunction = 'NVL'
		SET @DATEFunction = 'TO_CHAR'
		SET @DATEFormat = '''YYYY-MM-DD HH24:MI:SS'''
	END
END




IF @DataLoadMode = 'CDC'
	BEGIN
		SELECT @SQL = 'SELECT ''UPPER([__$start_lsn])'' AS SourceColumn, upper(sys.fn_varbintohexstr(sys.fn_cdc_get_max_lsn())) AS ReturnValue, sys.fn_cdc_map_lsn_to_time(sys.fn_cdc_get_max_lsn()) AS ReturnTime'
	END
ELSE
	BEGIN
		SET @TableName = @TableName + @SourceTable
		DECLARE @COL varchar(100)
		SET @COL = [CTL].[udf_GetMultiColFilterClause](@SourceColumn, @SourceColumn)
		SET @COL = [CTL].[udf_GetMultiColFilterClause](@COL, @SourceType)

		SET @SQL = @SQL + '''' + @COL + ''' As SourceColumn'
		SET @SQL = @SQL + ', ' + @DATEFunction + '(MAX(' + @COL + '), ' + @DATEFormat + ') As ReturnValue'

		SET @SQL = @SQL + ', COUNT(1) AS RecordCount'

		IF @ValidationColumn <> ''
		BEGIN
			SET @SQL = @SQL + ', SUM(' + @NULLFunction + '(' + @ValidationColumn + ',0)) AS TotalValue'
			SET @SQL = @SQL + ', MAX(' + @NULLFunction + '(' + @ValidationColumn + ',0)) AS MaxValue'
			SET @SQL = @SQL + ', MIN(' + @NULLFunction + '(' + @ValidationColumn + ',0)) AS MinValue'
		END
		ELSE
		BEGIN
			SET @SQL = @SQL + ', 0 AS TotalValue'
			SET @SQL = @SQL + ', 0 AS MaxValue'
			SET @SQL = @SQL + ', 0 AS MinValue'
		END

		SET @SQL = @SQL + ', ''' + @ValidationType + ''' AS ValidationType'

		IF UPPER(@ValidationType) = 'SOURCE'
			SET @SQL = @SQL + @TableName
		ELSE
		BEGIN
			SET @SQL = @SQL + ' FROM ' + 'edw.' + @SourceName + ' WHERE _RecordCurrent = 1 AND _RecordDeleted = 0'
		END


	END

SELECT @SQL SQLStatement

END
GO
PRINT N'Creating Procedure [CTL].[GetStorageFileName]...';


GO
CREATE proc [CTL].[GetStorageFileName] (
	@FolderName varchar(255)
	,@FileName varchar(255)
	,@Grain varchar(30)
	,@DeltaExtract bit
	,@TargetType varchar(255)
	,@Compressed bit = 1)
as
begin
	
	set @FolderName = LOWER(@FolderName)
	declare @DataType varchar(10)

	IF @TargetType = 'BLOB Storage (csv)' SET @DataType = 'csv'
	ELSE IF @TargetType = 'BLOB Storage (json)' SET @DataType = 'json'
	ELSE IF @TargetType = 'BLOB Storage (parquet)' SET @DataType = 'parquet'
	ELSE SET @DataType = 'csv'

	declare @blobfoldername varchar(1000)
	set @blobfoldername = @FolderName + '/' + @DataType + '/' + [CTL].[udf_GetFileDateHierarchy](@Grain) + '/'

	declare @blobfilename varchar(1000)
	IF @DeltaExtract = 1
	BEGIN
		set @blobfilename = @FileName + '_' + format([CTL].[udf_GetDateLocalTZ](),N'yyyy-MM-dd_HHmmss_fff') + '.' + @DataType
	END
	ELSE
	BEGIN
		set @blobfilename = @FileName + '_' + format([CTL].[udf_GetDateLocalTZ](),N'yyyy-MM-dd') + '.' + @DataType
		--Sometimes when the file with the same name is overwritten, Databricks does not read any record
		--Trying to check if having a unique name helps
		set @blobfilename = @FileName + '_' + format([CTL].[udf_GetDateLocalTZ](),N'yyyy-MM-dd_HHmmss_fff') + '.' + @DataType
	END

	IF @Compressed = 1 SET @blobfilename = @blobfilename + '.gz'


	SELECT @blobfoldername AS StorageFolder, @blobfilename AS StorageFile

end
GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
